<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiwanese Pinball Simulation</title>
    <style>
        /* Basic styling for the page */
        body {
            font-family: 'Inter', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
        }
        h1 {
            color: #6a4f40;
            margin-bottom: 10px;
        }

        /* Main game area layout */
        #gameContainer {
            display: flex;
            flex-direction: row; /* Arrange items horizontally */
            align-items: flex-start; /* Align items to the top */
            justify-content: center; /* Center the whole container */
            gap: 15px; /* Space between canvas and word lists */
            margin-top: 10px;
        }

        /* Word list styling */
        .wordList {
            width: 120px; /* Fixed width for word lists */
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            height: calc(600px - 22px); /* Match canvas height minus padding/border */
            overflow-y: auto; /* Scroll if content overflows */
            font-size: 0.9em;
        }
        .wordList h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            color: #5d4037;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .wordList ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .wordList ul li {
            padding: 3px 0;
            border-bottom: 1px dashed #eee;
            word-wrap: break-word; /* Ensure long words break */
        }
        .wordList ul li:last-child {
            border-bottom: none;
        }

        /* Canvas styling */
        canvas {
            border: 3px solid #4a3b31;
            background-color: #deb887;
            display: block;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        /* Controls container styling */
        #controls {
            margin-top: 20px;
            padding: 15px 20px;
            background-color: #fff8e1;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        #controls p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #5d4037;
        }
        /* Button styling */
        button {
            padding: 12px 20px;
            font-size: 1.05em;
            background-color: #c87638;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        button:hover {
            background-color: #b5652c;
            transform: translateY(-1px);
        }
        button:active {
            background-color: #a05420;
            transform: translateY(0px);
        }
        /* Instructions styling */
        #instructions {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.95em;
            color: #666;
            max-width: 400px; /* Max width for instructions below canvas */
            text-align: center;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }


        /* Quiz Modal Styling */
        #quizModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #quizContent {
            background-color: #fff8e1;
            padding: 25px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 450px;
            border: 2px solid #c87638;
        }
        #quizContent h2 {
            color: #6a4f40;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #quizQuestion {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
        #quizAnswerInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: calc(100% - 22px);
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #quizMessage {
            margin-top: 10px;
            font-weight: bold;
            min-height: 1.2em;
        }
        .quizCorrect { color: green; }
        .quizIncorrect { color: red; }
        #quizButtons button {
            margin: 5px;
        }

    </style>
</head>
<body>

    <h1>Taiwanese Pinball</h1>

    <div id="gameContainer">
        <div id="incorrectWordsList" class="wordList">
            <h3>Incorrect Guesses</h3>
            <ul id="incorrectWordsUl"></ul>
        </div>
        <canvas id="pinballCanvas"></canvas>
        <div id="correctWordsList" class="wordList">
            <h3>Correct Answers</h3>
            <ul id="correctWordsUl"></ul>
        </div>
    </div>

    <div id="controls">
        <p>Marbles Left: <span id="marblesLeft">0</span></p>
        <p>Score: <span id="score">0</span></p>
        <button id="resetButton">New Game</button>
    </div>
    <div id="instructions">
        <p>Click and drag the plunger (bottom right) downwards to set power, then release to launch.</p>
        <p style="font-size:0.8em; color: #777;">(Note: "Marbles Left" shows your reserve. One is used when loaded into the plunger.)</p>
    </div>

    <div id="quizModal">
        <div id="quizContent">
            <h2>Quiz Time!</h2>
            <p id="quizQuestion">Question text will appear here.</p>
            <input type="text" id="quizAnswerInput" placeholder="Your answer">
            <div id="quizButtons">
                <button id="submitAnswerButton">Submit Answer</button>
                <button id="closeQuizButton">Close Quiz</button>
            </div>
            <p id="quizMessage"></p>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const useExternalVocabFile = true; // Set to true to attempt loading Vocab.txt, false to use hardcoded
    const vocabFileName = "Vocab.txt"; // Name of the external vocab file

    // Get canvas and context
    const canvas = document.getElementById('pinballCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const marblesLeftEl = document.getElementById('marblesLeft');
    const scoreEl = document.getElementById('score');
    const resetButton = document.getElementById('resetButton');

    // Word list UL elements
    const correctWordsUl = document.getElementById('correctWordsUl');
    const incorrectWordsUl = document.getElementById('incorrectWordsUl');

    // Quiz Modal Elements
    const quizModal = document.getElementById('quizModal');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizAnswerInput = document.getElementById('quizAnswerInput');
    const submitAnswerButton = document.getElementById('submitAnswerButton');
    const closeQuizButton = document.getElementById('closeQuizButton');
    const quizMessageEl = document.getElementById('quizMessage');


    // Game settings
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MARBLE_RADIUS = 8;
    const PEG_RADIUS = 4;
    const GRAVITY = 0.15;
    const BOUNCE_FACTOR = 0.65;
    const LAUNCH_AREA_HEIGHT = 80;
    const PLUNGER_WIDTH = 20;
    const PLUNGER_HEIGHT = 70;
    const MAX_PULL_DISTANCE = 60;
    const INITIAL_MARBLES = 5;

    // Set canvas dimensions
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Game state variables
    let marbles = [];
    let pegs = [];
    let holes = [];
    let playerMarbles; // Marbles in supply
    let score;
    let currentMarble = null; // Marble in plunger
    let isDraggingPlunger = false;
    let plungerPullDistance = 0;
    let gameLoopId;
    let isQuizModeActive = false;
    let currentQuizQuestionObj = null;
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let needsNewMarbleInPlunger = false;
    let quizQuestions = []; // Will be populated from parsed vocab data

    // Plunger properties
    const plunger = {
        x: CANVAS_WIDTH - PLUNGER_WIDTH - 15,
        baseY: CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT + (LAUNCH_AREA_HEIGHT - PLUNGER_HEIGHT) / 2,
        width: PLUNGER_WIDTH,
        height: PLUNGER_HEIGHT,
        color: '#4a3b31'
    };
    plunger.y = plunger.baseY;

    // Hardcoded fallback content of Vocab.txt
    const hardcodedVocabFileContent = `Is it true that humans are naturally born with the (a)________________ to learn a language?:-ability;-0.5
My college in Japan offers a six-month study (a)________________ program in California.:-abroad;-0.5
The missing child was found (a)________________ from home, but safe.:-absent;-0.3
The (a)________________ of rain for many months caused a serious drought.:-absence;-0.3
This is an (a)________________ disaster! We need to evacuate immediately!:-absolute;-0.7
The professor's explanation was so clear that the complex theory became (a)________________ understandable.:-absolutely;-0.7
The sponge can (a)________________ a lot of water.:-absorb;-0.4
His research paper was too (a)________________ and difficult for most people to understand.:-abstract;-0.6
Putting a child in a cage is a form of child (a)________________.:-abuse;-0.8
She received many (a)________________ awards for her work in science.:-academic;-0.5
The university is famous for its high (a)________________ standards.:-academy;-0.5`;

    /**
     * Parses the vocab data string and populates the quizQuestions array.
     * Expected format per line: CLUE_TEXT_WITH_PLACEHOLDER:-ANSWER;-POINTS
     * The points part (e.g., ";-0.5") is ignored for the stored answer.
     */
    function parseVocabData(dataString) {
        const lines = dataString.trim().split('\n');
        const parsedQuestions = [];
        const placeholder = "(a)________________";

        lines.forEach(line => {
            if (line.trim() === "") return; // Skip empty lines
            const parts = line.split(':-'); // Separates clue from answer+points
            if (parts.length >= 2) {
                const clueWithPlaceholder = parts[0];
                // parts[1] might be "answer" or "answer;-points"
                const answerPart = parts[1].split(';')[0]; // Take only the part before the first semicolon

                const placeholderIndex = clueWithPlaceholder.indexOf(placeholder);
                let textPart1 = "";
                let textPart2 = "";

                if (placeholderIndex !== -1) {
                    textPart1 = clueWithPlaceholder.substring(0, placeholderIndex);
                    textPart2 = clueWithPlaceholder.substring(placeholderIndex + placeholder.length);
                } else {
                    textPart1 = clueWithPlaceholder; // Fallback if placeholder missing
                }
                // Store only the clue parts and the trimmed answer word.
                parsedQuestions.push({
                    textPart1: textPart1.trim(),
                    textPart2: textPart2.trim(),
                    answer: answerPart.trim()
                });
            } else {
                console.warn("Skipping malformed vocab line:", line);
            }
        });
        return parsedQuestions;
    }

    /**
     * Attempts to load vocabulary from an external file, falling back to hardcoded data.
     */
    async function loadVocabulary() {
        if (useExternalVocabFile) {
            try {
                const response = await fetch(vocabFileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} when fetching ${vocabFileName}`);
                }
                const dataString = await response.text();
                console.log("Successfully loaded vocab from:", vocabFileName);
                quizQuestions = parseVocabData(dataString);
            } catch (error) {
                console.warn("Could not load external vocab file. Error:", error, "Falling back to hardcoded vocabulary.");
                quizQuestions = parseVocabData(hardcodedVocabFileContent);
            }
        } else {
            console.log("Using hardcoded vocabulary.");
            quizQuestions = parseVocabData(hardcodedVocabFileContent);
        }
        if (quizQuestions.length === 0) {
            console.error("No quiz questions loaded! Check vocab data source and format.");
        }
    }


    /**
     * Initializes or resets the game state. Now an async function.
     */
    async function initGame() {
        await loadVocabulary(); // Wait for vocabulary to be loaded/parsed

        playerMarbles = INITIAL_MARBLES;
        score = 0;
        marbles = [];
        currentMarble = null;
        isDraggingPlunger = false;
        plungerPullDistance = 0;
        isQuizModeActive = false;
        quizModal.style.display = 'none';
        correctAnswersCount = 0;
        incorrectAnswersCount = 0;
        needsNewMarbleInPlunger = true;
        correctWordsUl.innerHTML = '';
        incorrectWordsUl.innerHTML = '';
        updateUI();
        setupBoard();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoop();
    }

    /**
     * Sets up the pegs and winning holes on the game board.
     */
    function setupBoard() {
        pegs = [];
        holes = [];
        const rows = 13;
        const cols = 8;
        const xSpacing = (CANVAS_WIDTH - 40) / cols;
        const ySpacing = (CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 180) / rows;
        const xOffset = 20;
        const marbleStartX = plunger.x + PLUNGER_WIDTH / 2;
        const marbleStartY = plunger.baseY - MARBLE_RADIUS - 5;

        const clearRectX1 = marbleStartX - 150;
        const clearRectX2 = marbleStartX + MARBLE_RADIUS + 20;
        const clearRectY1 = marbleStartY - 300; // Peg clearance updated
        const clearRectY2 = CANVAS_HEIGHT;

        for (let i = 0; i < rows; i++) {
            const numColsThisRow = (i % 2 === 0) ? cols : cols - 1;
            for (let j = 0; j < numColsThisRow; j++) {
                let pegX = (j * xSpacing) + xOffset;
                if (i % 2 !== 0) {
                    pegX += xSpacing / 2;
                }
                const pegY = 90 + i * ySpacing;
                let skipPeg = false;

                if (pegX > clearRectX1 && pegX < clearRectX2 &&
                    pegY > clearRectY1 && pegY < clearRectY2) {
                    skipPeg = true;
                }

                if (!skipPeg && pegX + PEG_RADIUS < CANVAS_WIDTH - xOffset && pegX - PEG_RADIUS > xOffset) {
                     pegs.push({ x: pegX, y: pegY, radius: PEG_RADIUS, color: '#704214' });
                }
            }
        }
        const holeValues = [50, 25, 10, 5, 3, 1, -5];
        const holeRadius = 16;
        const holeY = CANVAS_HEIGHT - 60;
        const numHoles = holeValues.length;
        const holeSpacing = (CANVAS_WIDTH - 40) / (numHoles);
        const firstHoleX = 20 + holeSpacing / 2;
        for (let i = 0; i < numHoles; i++) {
            holes.push({
                x: firstHoleX + i * holeSpacing,
                y: holeY,
                radius: holeRadius,
                value: holeValues[i],
                color: `hsl(${20 + i * (300 / numHoles)}, 70%, 55%)`
            });
        }
    }

    /**
     * Updates the displayed score, number of marbles left in supply.
     */
    function updateUI() {
        marblesLeftEl.textContent = playerMarbles;
        scoreEl.textContent = score;
    }

    /**
     * Creates a new marble object for the plunger if supply allows.
     */
    function createMarble() {
        if (playerMarbles > 0) {
            playerMarbles--;
            currentMarble = {
                x: plunger.x + PLUNGER_WIDTH / 2,
                y: plunger.baseY - MARBLE_RADIUS - 5,
                radius: MARBLE_RADIUS,
                vx: 0, vy: 0,
                color: `hsl(${Math.random() * 360}, 85%, 65%)`,
                isActive: false,
                hasHitPeg: false
            };
            marbles.push(currentMarble);
            updateUI();
            return true;
        }
        updateUI();
        return false;
    }

    /**
     * Launches the 'currentMarble' and sets plunger to empty.
     */
    function launchMarble(power) {
        if (currentMarble && !currentMarble.isActive) {
            currentMarble.isActive = true;
            const baseAngle = -Math.PI * (2/3);
            const randomFactor = (Math.random() * Math.PI / 18) - (Math.PI / 36);
            const angle = baseAngle + randomFactor;
            currentMarble.vx = power * Math.cos(angle);
            currentMarble.vy = power * Math.sin(angle);
            currentMarble = null;
        }
    }

    /**
     * Draws the plunger mechanism.
     */
    function drawPlunger() {
        ctx.fillStyle = '#a0522d';
        ctx.beginPath();
        ctx.moveTo(plunger.x - 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x - 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.lineTo(plunger.x - 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = plunger.color;
        const currentPlungerY = plunger.baseY + plungerPullDistance;
        const currentPlungerHeight = plunger.height - plungerPullDistance;
        ctx.fillRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#332a23';
        ctx.strokeRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 3;
        const springTopY = plunger.baseY + plunger.height;
        const springBottomY = currentPlungerY + currentPlungerHeight;
        if (springBottomY > springTopY) {
            for(let i=0; i < 4; i++) {
                ctx.beginPath();
                const yPos = springTopY + (i * (springBottomY - springTopY) / 4);
                ctx.moveTo(plunger.x + PLUNGER_WIDTH/2 - 6, yPos);
                ctx.lineTo(plunger.x + PLUNGER_WIDTH/2 + 6, yPos + (springBottomY - springTopY) / 8);
                ctx.stroke();
            }
        }
    }

    /**
     * Draws all marbles from the 'marbles' array.
     */
    function drawMarbles() {
        marbles.forEach(marble => {
            if (marble) {
                ctx.beginPath();
                ctx.arc(marble.x, marble.y, marble.radius, 0, Math.PI * 2);
                ctx.fillStyle = marble.color;
                ctx.fill();
                if (marble.isActive) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        });
    }

    /**
     * Draws all pegs on the canvas.
     */
    function drawPegs() {
        pegs.forEach(peg => {
            ctx.beginPath();
            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
            ctx.fillStyle = peg.color;
            ctx.fill();
            ctx.strokeStyle = '#503010';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    /**
     * Draws all winning holes on the canvas.
     */
    function drawHoles() {
        holes.forEach(hole => {
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, hole.radius - 3, 0, Math.PI * 2);
            ctx.fillStyle = hole.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'white';
            let fontSize = 12;
            if (hole.value >= 100 || hole.value <= -10) fontSize = 8;
            else if (hole.value >= 10 || hole.value < 0) fontSize = 10;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(hole.value, hole.x, hole.y);
        });
    }

    /**
     * Updates the position and physics of all active marbles.
     */
    function updateMarbles() {
        for (let i = marbles.length - 1; i >= 0; i--) {
            const marble = marbles[i];
            if (!marble || !marble.isActive) continue;

            marble.vy += GRAVITY;
            marble.x += marble.vx;
            marble.y += marble.vy;

            if (marble.x - marble.radius < 0) {
                marble.x = marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            } else if (marble.x + marble.radius > CANVAS_WIDTH) {
                marble.x = CANVAS_WIDTH - marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            }
            if (marble.y - marble.radius < 0 && marble.vy < 0) {
                marble.y = marble.radius;
                marble.vy *= -BOUNCE_FACTOR;
            }

            pegs.forEach(peg => {
                const dx = marble.x - peg.x;
                const dy = marble.y - peg.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadii = marble.radius + peg.radius;
                if (distance < combinedRadii) {
                    marble.hasHitPeg = true;
                    const overlap = combinedRadii - distance;
                    const angle = Math.atan2(dy, dx);
                    marble.x += Math.cos(angle) * overlap * 0.5;
                    marble.y += Math.sin(angle) * overlap * 0.5;
                    const normalX = dx / distance;
                    const normalY = dy / distance;
                    const dotProduct = marble.vx * normalX + marble.vy * normalY;
                    marble.vx = (marble.vx - 2 * dotProduct * normalX) * BOUNCE_FACTOR;
                    marble.vy = (marble.vy - 2 * dotProduct * normalY) * BOUNCE_FACTOR;
                    marble.vx += (Math.random() - 0.5) * 0.3;
                    marble.vy += (Math.random() - 0.5) * 0.3;
                }
            });

            let marbleRemoved = false;
            holes.forEach(hole => {
                const dx = marble.x - hole.x;
                const dy = marble.y - hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hole.radius) {
                    score += hole.value;
                    marbles.splice(i, 1);
                    marbleRemoved = true;
                    updateUI();
                    if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                        needsNewMarbleInPlunger = true;
                    }
                    return;
                }
            });

            if (marbleRemoved) continue;

            if (marble.y - marble.radius > CANVAS_HEIGHT) {
                if (!marble.hasHitPeg) {
                    score = Math.max(0, score - 1);
                }
                marbles.splice(i, 1);
                updateUI();
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                    needsNewMarbleInPlunger = true;
                }
            }
        }
    }

    /**
     * Main game loop.
     */
    function gameLoop() {
        if (isQuizModeActive) {
            return;
        }
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawPlunger();
        drawPegs();
        drawHoles();
        drawMarbles();

        if (needsNewMarbleInPlunger && playerMarbles > 0 && !currentMarble && !isQuizModeActive) {
            if (!marbles.some(m => m && m.isActive)) {
                createMarble();
                needsNewMarbleInPlunger = false;
            }
        }

        if (marbles.some(m => m && m.isActive)) {
             updateMarbles();
        }

        if (playerMarbles <= 0 && !marbles.some(m => m && m.isActive) && !currentMarble) {
            enterQuizMode();
        } else {
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    /**
     * Displays the final game over message on the canvas.
     */
    function displayGameOverMessage() {
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 120);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 15);
        ctx.font = '20px Arial';
        ctx.fillText('Final Score: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    }

    /**
     * Enters the quiz mode.
     */
    function enterQuizMode() {
        if (isQuizModeActive) return;
        if (quizQuestions.length === 0) {
            displayGameOverMessage();
            return;
        }
        isQuizModeActive = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        loadNewQuizQuestion();
        quizModal.style.display = 'flex';
        quizAnswerInput.value = '';
        quizAnswerInput.focus();
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    /**
     * Loads and displays a new random quiz question.
     */
    function loadNewQuizQuestion() {
        if (quizQuestions.length === 0) {
            quizQuestionEl.textContent = "No more questions available.";
            submitAnswerButton.disabled = true;
            return;
        }
        const randomIndex = Math.floor(Math.random() * quizQuestions.length);
        currentQuizQuestionObj = quizQuestions[randomIndex];
        quizQuestionEl.innerHTML = `${currentQuizQuestionObj.textPart1} <b>(a)___________</b> ${currentQuizQuestionObj.textPart2}`;
        //quizQuestionEl.innerHTML = `${currentQuizQuestionObj.textPart1} ${currentQuizQuestionObj.textPart2}`;
        quizAnswerInput.value = '';
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
        submitAnswerButton.disabled = false;
    }

    /**
     * Adds a word to the specified list UL element on the page.
     */
    function addWordToList(word, listElement, isCorrect) {
        const li = document.createElement('li');
        if (isCorrect) {
            correctAnswersCount++;
            li.textContent = `${correctAnswersCount}. ${word}`;
        } else {
            incorrectAnswersCount++;
            li.textContent = `${incorrectAnswersCount}. ${word}`;
        }
        listElement.appendChild(li);
        listElement.scrollTop = listElement.scrollHeight;
    }

    /**
     * Handles quiz answer submission.
     */
    function handleSubmitQuizAnswer() {
        if (!currentQuizQuestionObj || !isQuizModeActive) return;
        const userAnswer = quizAnswerInput.value.trim();
        const correctAnswer = currentQuizQuestionObj.answer;

        if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
            quizMessageEl.textContent = 'Correct! You get 1 marble.';
            quizMessageEl.className = 'quizCorrect';
            playerMarbles++;
            updateUI();
            addWordToList(correctAnswer, correctWordsUl, true);
            submitAnswerButton.disabled = true;
            setTimeout(() => {
                loadNewQuizQuestion();
                quizAnswerInput.focus();
                submitAnswerButton.disabled = false;
            }, 1500);
        } else {
            quizMessageEl.textContent = 'Incorrect. Try another question!';
            quizMessageEl.className = 'quizIncorrect';
            addWordToList(correctAnswer, incorrectWordsUl, false);
            submitAnswerButton.disabled = true;
            setTimeout(() => {
                loadNewQuizQuestion();
                quizAnswerInput.focus();
                submitAnswerButton.disabled = false;
            }, 1500);
        }
    }

    /**
     * Closes the quiz modal and handles game state (resume or game over).
     */
    function handleCloseQuiz() {
        quizModal.style.display = 'none';
        isQuizModeActive = false;
        if (playerMarbles <= 0 && !currentMarble && !marbles.some(m=> m && m.isActive)) {
            displayGameOverMessage();
        } else {
            if (playerMarbles > 0 && !currentMarble && !marbles.some(m => m && m.isActive)) {
                 needsNewMarbleInPlunger = true;
            }
            gameLoop();
        }
    }

    // Event Listeners for Plunger Interaction
    let startMouseY;
    canvas.addEventListener('mousedown', (e) => {
        if (isQuizModeActive) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (mouseX >= plunger.x && mouseX <= plunger.x + plunger.width &&
            mouseY >= plunger.baseY && mouseY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) {

            if (!currentMarble) {
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive)) {
                    createMarble();
                } else {
                    return;
                }
            }
            if (currentMarble && !currentMarble.isActive) {
                isDraggingPlunger = true;
                startMouseY = mouseY;
                plungerPullDistance = 0;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        const rect = canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        let pull = mouseY - startMouseY;
        if (pull < 0) pull = 0;
        if (pull > MAX_PULL_DISTANCE) pull = MAX_PULL_DISTANCE;
        plungerPullDistance = pull;
    });

    canvas.addEventListener('mouseup', () => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        isDraggingPlunger = false;
        if (plungerPullDistance > 5) {
            const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4;
            launchMarble(launchPower);
        }
        plungerPullDistance = 0;
    });

    canvas.addEventListener('mouseleave', () => {
        if (isQuizModeActive || !isDraggingPlunger) return;
         if (isDraggingPlunger) {
            isDraggingPlunger = false;
            if (plungerPullDistance > 5) {
                const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4;
                launchMarble(launchPower);
            }
            plungerPullDistance = 0;
        }
    });

    // Quiz Event Listeners
    submitAnswerButton.addEventListener('click', handleSubmitQuizAnswer);
    quizAnswerInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            handleSubmitQuizAnswer();
        }
    });
    closeQuizButton.addEventListener('click', handleCloseQuiz);

    // Reset button functionality
    resetButton.addEventListener('click', initGame);

    // Start the game automatically on load
    initGame(); // This is now async

</script>

</body>
</html>
