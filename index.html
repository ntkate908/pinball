<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andy's Pinball</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic styling for the page */
        body {
            font-family: 'Inter', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
        }
        h1 {
            color: #6a4f40;
            margin-bottom: 10px;
        }

        /* Main game area layout */
        #gameContainer {
            display: flex;
            flex-direction: row; /* Arrange items horizontally */
            align-items: flex-start; /* Align items to the top */
            justify-content: center; /* Center the whole container */
            gap: 15px; /* Space between canvas and word lists */
            margin-top: 10px;
        }

        /* Word list styling */
        .wordList {
            width: 120px; /* Fixed width for word lists */
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            height: calc(600px - 22px); /* Match canvas height minus padding/border */
            overflow-y: auto; /* Scroll if content overflows */
            font-size: 0.9em;
        }
        .wordList h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            color: #5d4037;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .wordList ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .wordList ul li {
            padding: 3px 0;
            border-bottom: 1px dashed #eee;
            word-wrap: break-word; /* Ensure long words break */
        }
        .wordList ul li:last-child {
            border-bottom: none;
        }

        /* Canvas styling */
        canvas {
            border: 3px solid #4a3b31;
            background-color: #deb887;
            display: block;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        /* Controls container styling */
        #controls {
            margin-top: 20px;
            padding: 15px 20px;
            background-color: #fff8e1;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        #controls p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #5d4037;
        }
        /* Button styling */
        button {
            padding: 12px 20px;
            font-size: 1.05em;
            background-color: #c87638;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        button:hover {
            background-color: #b5652c;
            transform: translateY(-1px);
        }
        button:active {
            background-color: #a05420;
            transform: translateY(0px);
        }
        /* Instructions styling */
        #instructions {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.95em;
            color: #666;
            max-width: 400px; /* Max width for instructions below canvas */
            text-align: center;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }


        /* Quiz Modal Styling */
        #quizModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #quizContent {
            background-color: #fff8e1;
            padding: 25px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 450px;
            border: 2px solid #c87638;
        }
        #quizContent h2 {
            color: #6a4f40;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #quizQuestion {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
        #quizAnswerInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: calc(100% - 22px);
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #quizMessage {
            margin-top: 10px;
            font-weight: bold;
            min-height: 1.2em;
        }
        .quizCorrect { color: green; }
        .quizIncorrect { color: red; }
        #quizButtons button {
            margin: 5px;
        }

    </style>
</head>
<body>

    <h1>Andy's Pinball</h1>

    <div id="gameContainer">
        <div id="incorrectWordsList" class="wordList">
            <h3>Incorrect Guesses</h3>
            <ul id="incorrectWordsUl"></ul>
        </div>
        <canvas id="pinballCanvas"></canvas>
        <div id="correctWordsList" class="wordList">
            <h3>Correct Answers</h3>
            <ul id="correctWordsUl"></ul>
        </div>
    </div>

    <div id="controls">
        <p>Marbles Left: <span id="marblesLeft">0</span></p>
        <p>Score: <span id="score">0</span></p>
        <button id="resetButton">New Game</button>
    </div>
    <div id="instructions">
        <p>Click and drag the plunger (bottom right) downwards to set power, then release to launch.</p>
        <p style="font-size:0.8em; color: #777;">(Note: "Marbles Left" shows your reserve. One is used when loaded into the plunger.)</p>
    </div>

    <div id="quizModal">
        <div id="quizContent">
            <h2>Quiz Time!</h2>
            <p id="quizQuestion">Question text will appear here.</p>
            <input type="text" id="quizAnswerInput" placeholder="Your answer">
            <div id="quizButtons">
                <button id="submitAnswerButton">Submit Answer</button>
                <button id="closeQuizButton">Close Quiz</button>
            </div>
            <p id="quizMessage"></p>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const useExternalVocabFile = true; 
    const vocabFileName = "Vocab.txt"; 

    // Get canvas and context
    const canvas = document.getElementById('pinballCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const marblesLeftEl = document.getElementById('marblesLeft');
    const scoreEl = document.getElementById('score');
    const resetButton = document.getElementById('resetButton');

    // Word list UL elements
    const correctWordsUl = document.getElementById('correctWordsUl');
    const incorrectWordsUl = document.getElementById('incorrectWordsUl');

    // Quiz Modal Elements
    const quizModal = document.getElementById('quizModal');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizAnswerInput = document.getElementById('quizAnswerInput');
    const submitAnswerButton = document.getElementById('submitAnswerButton');
    const closeQuizButton = document.getElementById('closeQuizButton');
    const quizMessageEl = document.getElementById('quizMessage');


    // Game settings
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MARBLE_RADIUS = 8;
    const PEG_RADIUS = 4;
    const GRAVITY = 0.15;
    const BOUNCE_FACTOR = 0.65;
    const LAUNCH_AREA_HEIGHT = 80;
    const PLUNGER_WIDTH = 20;
    const PLUNGER_HEIGHT = 70;
    const MAX_PULL_DISTANCE = 60;
    const INITIAL_MARBLES = 5;
    const HOLE_ANIMATION_DURATION = 300; // ms for hole light-up/enlarge effect

    // Set canvas dimensions
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Game state variables
    let marbles = [];
    let pegs = [];
    let holes = [];
    let playerMarbles; 
    let score;
    let currentMarble = null; 
    let isDraggingPlunger = false;
    let plungerPullDistance = 0;
    let gameLoopId;
    let isQuizModeActive = false;
    let currentQuizQuestionObj = null;
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let needsNewMarbleInPlunger = false;
    let quizQuestions = []; 

    // --- Audio Setup (Tone.js) ---
    let audioContextStarted = false;
    let pegHitSynth = null;
    let holeHitSynth = null;

    function initializeAudio() {
        if (typeof Tone !== 'undefined') {
            pegHitSynth = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 2,
                envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
                volume: -12 // Quieter peg hit
            }).toDestination();

            holeHitSynth = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                volume: -6
            }).toDestination();
            console.log("Audio synthesizers initialized.");
        } else {
            console.warn("Tone.js is not loaded. Sound effects will be disabled.");
        }
    }
    // Call initializeAudio early, but Tone.start() will be called on user interaction
    initializeAudio();


    // Plunger properties
    const plunger = {
        x: CANVAS_WIDTH - PLUNGER_WIDTH - 15,
        baseY: CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT + (LAUNCH_AREA_HEIGHT - PLUNGER_HEIGHT) / 2,
        width: PLUNGER_WIDTH,
        height: PLUNGER_HEIGHT,
        color: '#4a3b31'
    };
    plunger.y = plunger.baseY;

    const hardcodedVocabFileContent = `Is it true that humans are naturally born with the (a)________________ to learn a language?:-ability;-0.5
My college in Japan offers a six-month study (a)________________ program in California.:-abroad;-0.5
The missing child was found (a)________________ from home, but safe.:-absent;-0.3
The (a)________________ of rain for many months caused a serious drought.:-absence;-0.3
This is an (a)________________ disaster! We need to evacuate immediately!:-absolute;-0.7
The professor's explanation was so clear that the complex theory became (a)________________ understandable.:-absolutely;-0.7
The sponge can (a)________________ a lot of water.:-absorb;-0.4
His research paper was too (a)________________ and difficult for most people to understand.:-abstract;-0.6
Putting a child in a cage is a form of child (a)________________.:-abuse;-0.8
She received many (a)________________ awards for her work in science.:-academic;-0.5
The university is famous for its high (a)________________ standards.:-academy;-0.5
A clue that ends with the placeholder (a)________________:-endswithplaceholder;-0.2
A clue where textPart2 is the placeholder (a)________________ (a)________________:-placeholderastwo;-0.3`;

    function parseVocabData(dataString) {
        const lines = dataString.trim().split('\n');
        const parsedQuestions = [];
        const placeholder = "(a)________________"; 

        lines.forEach(line => {
            if (line.trim() === "") return; 
            const parts = line.split(':-'); 
            if (parts.length >= 2) {
                const clueWithPlaceholder = parts[0];
                const answerPart = parts[1].split(';')[0]; 

                const placeholderIndex = clueWithPlaceholder.indexOf(placeholder);
                let textPart1 = "";
                let textPart2 = "";

                if (placeholderIndex !== -1) {
                    textPart1 = clueWithPlaceholder.substring(0, placeholderIndex);
                    textPart2 = clueWithPlaceholder.substring(placeholderIndex + placeholder.length);
                } else {
                    textPart1 = clueWithPlaceholder; 
                }
                parsedQuestions.push({
                    textPart1: textPart1.trim(), 
                    textPart2: textPart2.trim(), 
                    answer: answerPart.trim()
                });
            } else {
                console.warn("Skipping malformed vocab line:", line);
            }
        });
        return parsedQuestions;
    }

    async function loadVocabulary() {
        if (useExternalVocabFile) {
            try {
                const response = await fetch(vocabFileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} when fetching ${vocabFileName}`);
                }
                const dataString = await response.text();
                console.log("Successfully loaded vocab from:", vocabFileName);
                quizQuestions = parseVocabData(dataString);
            } catch (error) {
                console.warn("Could not load external vocab file. Error:", error, "Falling back to hardcoded vocabulary.");
                quizQuestions = parseVocabData(hardcodedVocabFileContent);
            }
        } else {
            console.log("Using hardcoded vocabulary.");
            quizQuestions = parseVocabData(hardcodedVocabFileContent);
        }
        if (quizQuestions.length === 0) {
            console.error("No quiz questions loaded! Check vocab data source and format.");
            if (quizQuestions.length === 0) {
                 quizQuestions = parseVocabData("This is a default question (a)________________ if loading fails.:-default;-0.1");
            }
        }
    }

    async function initGame() {
        await loadVocabulary(); 

        playerMarbles = INITIAL_MARBLES;
        score = 0;
        marbles = [];
        currentMarble = null;
        isDraggingPlunger = false;
        plungerPullDistance = 0;
        isQuizModeActive = false;
        quizModal.style.display = 'none';
        correctAnswersCount = 0;
        incorrectAnswersCount = 0;
        needsNewMarbleInPlunger = true;
        correctWordsUl.innerHTML = '';
        incorrectWordsUl.innerHTML = '';
        updateUI();
        setupBoard();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoop();
    }

    function setupBoard() {
        pegs = [];
        holes = [];
        const rows = 13;
        const cols = 8;
        const xSpacing = (CANVAS_WIDTH - 40) / cols;
        const ySpacing = (CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 180) / rows;
        const xOffset = 20;
        const marbleStartX = plunger.x + PLUNGER_WIDTH / 2;
        const marbleStartY = plunger.baseY - MARBLE_RADIUS - 5;

        const clearRectX1 = marbleStartX - 150;
        const clearRectX2 = marbleStartX + MARBLE_RADIUS + 20;
        const clearRectY1 = marbleStartY - 300; 
        const clearRectY2 = CANVAS_HEIGHT;

        for (let i = 0; i < rows; i++) {
            const numColsThisRow = (i % 2 === 0) ? cols : cols - 1;
            for (let j = 0; j < numColsThisRow; j++) {
                let pegX = (j * xSpacing) + xOffset;
                if (i % 2 !== 0) {
                    pegX += xSpacing / 2;
                }
                const pegY = 90 + i * ySpacing;
                let skipPeg = false;

                if (pegX > clearRectX1 && pegX < clearRectX2 &&
                    pegY > clearRectY1 && pegY < clearRectY2) {
                    skipPeg = true;
                }

                if (!skipPeg && pegX + PEG_RADIUS < CANVAS_WIDTH - xOffset && pegX - PEG_RADIUS > xOffset) {
                     pegs.push({ x: pegX, y: pegY, radius: PEG_RADIUS, color: '#704214' });
                }
            }
        }
        
        const holeValues = [25, 50, -5, 10, 5, 15, -10];
        const baseHoleRadius = 19; 
        const holeY = CANVAS_HEIGHT - 60;
        const numHoles = holeValues.length;
        const holeSpacing = (CANVAS_WIDTH - 40) / (numHoles);
        const firstHoleX = 20 + holeSpacing / 2;
        for (let i = 0; i < numHoles; i++) {
            holes.push({
                x: firstHoleX + i * holeSpacing,
                y: holeY,
                baseRadius: baseHoleRadius, // Store original radius
                baseColor: `hsl(${20 + i * (300 / numHoles)}, 70%, 55%)`, // Store original color
                value: holeValues[i],
                hitAnimationEndTime: 0 // Timestamp for when animation ends
            });
        }
    }

    function updateUI() {
        marblesLeftEl.textContent = playerMarbles;
        scoreEl.textContent = score;
    }

    function createMarble() {
        if (playerMarbles > 0) {
            playerMarbles--;
            currentMarble = {
                x: plunger.x + PLUNGER_WIDTH / 2,
                y: plunger.baseY - MARBLE_RADIUS - 5,
                radius: MARBLE_RADIUS,
                vx: 0, vy: 0,
                color: `hsl(${Math.random() * 360}, 85%, 65%)`,
                isActive: false,
                hasHitPeg: false
            };
            marbles.push(currentMarble);
            updateUI();
            return true;
        }
        updateUI();
        return false;
    }

    function launchMarble(power) {
        if (currentMarble && !currentMarble.isActive) {
            currentMarble.isActive = true;
            const baseAngle = -Math.PI * (2/3); 
            const randomFactor = (Math.random() * Math.PI / 18) - (Math.PI / 36); 
            const angle = baseAngle + randomFactor;
            currentMarble.vx = power * Math.cos(angle);
            currentMarble.vy = power * Math.sin(angle);
            currentMarble = null; 
        }
    }

    function drawPlunger() {
        ctx.fillStyle = '#a0522d'; 
        ctx.beginPath();
        ctx.moveTo(plunger.x - 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x - 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.lineTo(plunger.x - 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = plunger.color;
        const currentPlungerY = plunger.baseY + plungerPullDistance;
        const currentPlungerHeight = plunger.height - plungerPullDistance;
        ctx.fillRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#332a23';
        ctx.strokeRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 3;
        const springTopY = plunger.baseY + plunger.height;
        const springBottomY = currentPlungerY + currentPlungerHeight;
        if (springBottomY > springTopY) {
            for(let i=0; i < 4; i++) {
                ctx.beginPath();
                const yPos = springTopY + (i * (springBottomY - springTopY) / 4);
                ctx.moveTo(plunger.x + PLUNGER_WIDTH/2 - 6, yPos);
                ctx.lineTo(plunger.x + PLUNGER_WIDTH/2 + 6, yPos + (springBottomY - springTopY) / 8);
                ctx.stroke();
            }
        }
    }

    function drawMarbles() {
        marbles.forEach(marble => {
            if (marble) {
                ctx.beginPath();
                ctx.arc(marble.x, marble.y, marble.radius, 0, Math.PI * 2);
                ctx.fillStyle = marble.color;
                ctx.fill();
                if (marble.isActive) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        });
    }

    function drawPegs() {
        pegs.forEach(peg => {
            ctx.beginPath();
            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
            ctx.fillStyle = peg.color;
            ctx.fill();
            ctx.strokeStyle = '#503010';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    /**
     * Draws all winning holes on the canvas, with animation for hits.
     */
    function drawHoles() {
        const now = Date.now();
        holes.forEach(hole => {
            let currentRadius = hole.baseRadius;
            let currentColor = hole.baseColor;
            let showHighlight = false;

            if (now < hole.hitAnimationEndTime) {
                // Animation is active
                const timeRemaining = hole.hitAnimationEndTime - now;
                const progress = 1 - (timeRemaining / HOLE_ANIMATION_DURATION); // 0 to 1

                // Pulsate size: expand then shrink back
                const scaleFactor = 1 + 0.2 * Math.sin(progress * Math.PI); // 1.0 -> 1.2 -> 1.0
                currentRadius = hole.baseRadius * scaleFactor;
                currentColor = '#FFFF99'; // Bright yellow highlight
                showHighlight = true;
            }

            // Outer shadow/depth
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
            ctx.fill();

            // Inner color part
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius - 3, 0, Math.PI * 2); 
            ctx.fillStyle = currentColor;
            ctx.fill();

            // Stroke for definition
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke(); 

            // Text styling for hole values
            ctx.fillStyle = showHighlight ? '#333' : 'white'; // Darker text on highlight
            let fontSize = 12;
            if (Math.abs(hole.value) >= 100 || (hole.value < 0 && Math.abs(hole.value) >= 10)) fontSize = 10;
            else if (Math.abs(hole.value) >= 10) fontSize = 11; 
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(hole.value, hole.x, hole.y);
        });
    }

    function updateMarbles() {
        for (let i = marbles.length - 1; i >= 0; i--) {
            const marble = marbles[i];
            if (!marble || !marble.isActive) continue;

            marble.vy += GRAVITY;
            marble.x += marble.vx;
            marble.y += marble.vy;

            if (marble.x - marble.radius < 0) {
                marble.x = marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            } else if (marble.x + marble.radius > CANVAS_WIDTH) {
                marble.x = CANVAS_WIDTH - marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            }
            if (marble.y - marble.radius < 0 && marble.vy < 0) { 
                marble.y = marble.radius;
                marble.vy *= -BOUNCE_FACTOR;
            }

            pegs.forEach(peg => {
                const dx = marble.x - peg.x;
                const dy = marble.y - peg.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadii = marble.radius + peg.radius;
                if (distance < combinedRadii) {
                    marble.hasHitPeg = true; 
                    const overlap = combinedRadii - distance;
                    const angle = Math.atan2(dy, dx);
                    marble.x += Math.cos(angle) * overlap * 0.5; 
                    marble.y += Math.sin(angle) * overlap * 0.5;
                    const normalX = dx / distance;
                    const normalY = dy / distance;
                    const dotProduct = marble.vx * normalX + marble.vy * normalY;
                    marble.vx = (marble.vx - 2 * dotProduct * normalX) * BOUNCE_FACTOR;
                    marble.vy = (marble.vy - 2 * dotProduct * normalY) * BOUNCE_FACTOR;
                    marble.vx += (Math.random() - 0.5) * 0.3; 
                    marble.vy += (Math.random() - 0.5) * 0.3;

                    // Play peg hit sound
                    if (pegHitSynth && audioContextStarted) {
                        pegHitSynth.triggerAttackRelease("C2", "8n", Tone.now());
                    }
                }
            });

            let marbleRemoved = false;
            holes.forEach(hole => {
                const dx = marble.x - hole.x;
                const dy = marble.y - hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Use baseRadius for collision detection, not the animated radius
                if (distance < hole.baseRadius) { 
                    score += hole.value;
                    marbles.splice(i, 1); 
                    marbleRemoved = true;
                    updateUI();

                    // Trigger hole hit animation and sound
                    hole.hitAnimationEndTime = Date.now() + HOLE_ANIMATION_DURATION;
                    if (holeHitSynth && audioContextStarted) {
                        let freq;
                        if (hole.value > 0) {
                            freq = 200 + hole.value * 8; // Higher positive score = higher pitch
                        } else if (hole.value < 0) {
                            freq = 150 + hole.value * 6; // Lower negative score = lower pitch (more dissonant)
                        } else { // hole.value === 0 or neutral
                            freq = 180;
                        }
                        freq = Math.max(80, Math.min(freq, 1200)); // Clamp frequency
                        holeHitSynth.triggerAttackRelease(freq, "8n", Tone.now());
                    }

                    if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                        needsNewMarbleInPlunger = true;
                    }
                    return; 
                }
            });

            if (marbleRemoved) continue; 

            if (marble.y - marble.radius > CANVAS_HEIGHT) {
                if (!marble.hasHitPeg) { 
                    score = Math.max(0, score - 1); 
                }
                marbles.splice(i, 1);
                updateUI();
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                    needsNewMarbleInPlunger = true;
                }
            }
        }
    }

    function gameLoop() {
        if (isQuizModeActive) {
            return; 
        }
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawPlunger();
        drawPegs();
        drawHoles(); // Will now handle animation
        drawMarbles();

        if (needsNewMarbleInPlunger && playerMarbles > 0 && !currentMarble && !isQuizModeActive) {
            if (!marbles.some(m => m && m.isActive)) { 
                createMarble();
                needsNewMarbleInPlunger = false;
            }
        }
        
        if (marbles.some(m => m && m.isActive)) { 
             updateMarbles();
        }

        if (playerMarbles <= 0 && !marbles.some(m => m && m.isActive) && !currentMarble) {
            enterQuizMode(); 
        } else {
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    function displayGameOverMessage() {
        if(gameLoopId) cancelAnimationFrame(gameLoopId); 
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 120);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 15);
        ctx.font = '20px Arial';
        ctx.fillText('Final Score: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    }
    
    function enterQuizMode() {
        if (isQuizModeActive) return; 
        if (quizQuestions.length === 0) {
            console.log("No quiz questions available, ending game.");
            displayGameOverMessage(); 
            return;
        }
        isQuizModeActive = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId); 

        loadNewQuizQuestion();
        quizModal.style.display = 'flex';
        quizAnswerInput.value = '';
        quizAnswerInput.focus();
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    function loadNewQuizQuestion() {
        if (quizQuestions.length === 0) {
            quizQuestionEl.textContent = "No more questions available.";
            submitAnswerButton.disabled = true;
            return;
        }
        const randomIndex = Math.floor(Math.random() * quizQuestions.length);
        currentQuizQuestionObj = quizQuestions[randomIndex];

        const displayBlank = "<b>(a)________________</b>"; 
        const vocabFilePlaceholder = "(a)________________"; 

        let part1 = currentQuizQuestionObj.textPart1; 
        let part2 = currentQuizQuestionObj.textPart2; 

        let finalQuizText = part1;
        if (part1 !== "") {
            finalQuizText += " "; 
        }
        finalQuizText += displayBlank;

        if (part2 !== "" && part2 !== vocabFilePlaceholder) {
            finalQuizText += ` ${part2}`;
        }
        
        quizQuestionEl.innerHTML = finalQuizText.trim(); 
        quizAnswerInput.value = '';
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
        submitAnswerButton.disabled = false;
    }

    function addWordToList(word, listElement, isCorrect) {
        const li = document.createElement('li');
        if (isCorrect) {
            correctAnswersCount++;
            li.textContent = `${correctAnswersCount}. ${word}`;
        } else {
            incorrectAnswersCount++;
            li.textContent = `${incorrectAnswersCount}. ${word}`;
        }
        listElement.appendChild(li);
        listElement.scrollTop = listElement.scrollHeight; 
    }

    function handleSubmitQuizAnswer() {
        if (!currentQuizQuestionObj || !isQuizModeActive) return;
        const userAnswer = quizAnswerInput.value.trim();
        const correctAnswer = currentQuizQuestionObj.answer;

        if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
            quizMessageEl.textContent = 'Correct! You get 1 marble.';
            quizMessageEl.className = 'quizCorrect';
            playerMarbles++;
            updateUI();
            addWordToList(correctAnswer, correctWordsUl, true);
            submitAnswerButton.disabled = true; 
            setTimeout(() => {
                loadNewQuizQuestion(); 
                quizAnswerInput.focus();
            }, 1500);
        } else {
            quizMessageEl.textContent = 'Incorrect. Try another question!';
            quizMessageEl.className = 'quizIncorrect';
            addWordToList(userAnswer || "[no answer]", incorrectWordsUl, false); 
            submitAnswerButton.disabled = true;
            setTimeout(() => {
                loadNewQuizQuestion();
                quizAnswerInput.focus();
            }, 1500);
        }
    }
    
    function handleCloseQuiz() {
        quizModal.style.display = 'none';
        isQuizModeActive = false;

        if (playerMarbles <= 0 && !currentMarble && !marbles.some(m=> m && m.isActive)) {
            displayGameOverMessage();
        } else {
            if (playerMarbles > 0 && !currentMarble && !marbles.some(m => m && m.isActive)) {
                 needsNewMarbleInPlunger = true;
            }
            gameLoop(); 
        }
    }

    // Event Listeners for Plunger Interaction
    let startMouseY;
    canvas.addEventListener('mousedown', async (e) => { // Made async for Tone.start()
        if (isQuizModeActive) return;

        // Start Tone.js audio context on first user interaction
        if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
            try {
                await Tone.start();
                audioContextStarted = true;
                console.log('Audio context started successfully.');
            } catch (error) {
                console.error('Failed to start audio context:', error);
            }
        }

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        if (mouseX >= plunger.x && mouseX <= plunger.x + plunger.width &&
            mouseY >= plunger.baseY && mouseY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) { 
            
            if (!currentMarble) { 
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive)) { 
                    createMarble(); 
                } else {
                    return; 
                }
            }

            if (currentMarble && !currentMarble.isActive) { 
                isDraggingPlunger = true;
                startMouseY = mouseY;
                plungerPullDistance = 0; 
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        const rect = canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        let pull = mouseY - startMouseY;
        if (pull < 0) pull = 0; 
        if (pull > MAX_PULL_DISTANCE) pull = MAX_PULL_DISTANCE; 
        plungerPullDistance = pull;
    });

    canvas.addEventListener('mouseup', () => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        isDraggingPlunger = false;
        if (plungerPullDistance > 5) { 
            const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4; 
            launchMarble(launchPower);
        }
        plungerPullDistance = 0; 
    });

    canvas.addEventListener('mouseleave', () => { 
        if (isQuizModeActive || !isDraggingPlunger) return;
         if (isDraggingPlunger) { 
            isDraggingPlunger = false;
            if (plungerPullDistance > 5) {
                const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4;
                launchMarble(launchPower);
            }
            plungerPullDistance = 0;
        }
    });

    // Quiz Event Listeners
    submitAnswerButton.addEventListener('click', handleSubmitQuizAnswer);
    quizAnswerInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            handleSubmitQuizAnswer();
        }
    });
    closeQuizButton.addEventListener('click', handleCloseQuiz);

    // Reset button functionality
    resetButton.addEventListener('click', initGame);

    // Start the game automatically on load
    initGame(); 

</script>

</body>
</html>
