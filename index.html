<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andy's Pinball</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic styling for the page */
        body {
            font-family: 'Inter', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
        }
        h1 {
            color: #6a4f40;
            margin-bottom: 10px;
        }

        /* Main game area layout */
        #gameContainer {
            display: flex;
            flex-direction: row; /* Arrange items horizontally */
            align-items: flex-start; /* Align items to the top */
            justify-content: center; /* Center the whole container */
            gap: 15px; /* Space between canvas and word lists */
            margin-top: 10px;
        }

        /* Word list styling */
        .wordList {
            width: 120px; /* Fixed width for word lists */
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            height: calc(600px - 22px); /* Match canvas height minus padding/border */
            overflow-y: auto; /* Scroll if content overflows */
            font-size: 0.9em;
        }
        .wordList h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            color: #5d4037;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .wordList ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .wordList ul li {
            padding: 3px 0;
            border-bottom: 1px dashed #eee;
            word-wrap: break-word; /* Ensure long words break */
        }
        .wordList ul li:last-child {
            border-bottom: none;
        }

        /* Canvas styling */
        canvas {
            border: 3px solid #4a3b31;
            display: block;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            touch-action: none; /* Important for preventing default touch actions like scrolling on the canvas */
            
            background-image: url('Background.png');
            background-size: cover; /* Cover the entire canvas */
            background-repeat: no-repeat; /* Do not repeat the image */
            background-position: center center; /* Center the image */
            background-color: #deb887; /* Fallback color if image fails to load or has transparency */
        }
        /* Controls container styling */
        #controls {
            margin-top: 20px;
            padding: 15px 20px;
            background-color: #fff8e1;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        #controls p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #5d4037;
        }
        /* Button styling */
        button {
            padding: 12px 20px;
            font-size: 1.05em;
            background-color: #c87638;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        button:hover {
            background-color: #b5652c;
            transform: translateY(-1px);
        }
        button:active {
            background-color: #a05420;
            transform: translateY(0px);
        }
        /* Instructions styling */
        #instructions {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.95em;
            color: #666;
            max-width: 400px; /* Max width for instructions below canvas */
            text-align: center;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }


        /* Quiz Modal Styling */
        #quizModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #quizContent {
            background-color: #fff8e1;
            padding: 25px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 450px;
            border: 2px solid #c87638;
        }
        #quizContent h2 {
            color: #6a4f40;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #quizQuestion {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
        #quizAnswerInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: calc(100% - 22px); /* Account for padding */
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #quizMessage {
            margin-top: 10px;
            font-weight: bold;
            min-height: 1.2em; /* Prevent layout shift */
        }
        .quizCorrect { color: green; }
        .quizIncorrect { color: red; }
        #quizButtons button {
            margin: 5px;
        }

    </style>
</head>
<body>

    <h1>Andy's Pinball</h1>

    <div id="gameContainer">
        <div id="incorrectWordsList" class="wordList">
            <h3>Incorrect Guesses (Correct Answers)</h3>
            <ul id="incorrectWordsUl"></ul>
        </div>
        <canvas id="pinballCanvas"></canvas>
        <div id="correctWordsList" class="wordList">
            <h3>Correct Answers</h3>
            <ul id="correctWordsUl"></ul>
        </div>
    </div>

    <div id="controls">
        <p>Marbles Left: <span id="marblesLeft">0</span></p>
        <p>Score: <span id="score">0</span></p>
        <button id="resetButton">New Game</button>
    </div>
    <div id="instructions">
        <p>Click/Tap and drag the plunger (bottom right) downwards to set power, then release to launch.</p>
        <p style="font-size:0.8em; color: #777;">(Note: "Marbles Left" shows your reserve. One is used when loaded into the plunger.)</p>
    </div>

    <div id="quizModal">
        <div id="quizContent">
            <h2>Quiz Time!</h2>
            <p id="quizQuestion">Question text will appear here.</p>
            <input type="text" id="quizAnswerInput" placeholder="Your answer">
            <div id="quizButtons">
                <button id="submitAnswerButton">Submit Answer</button>
                <button id="closeQuizButton">Close Quiz</button>
            </div>
            <p id="quizMessage"></p>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const useExternalVocabFile = true; 
    const vocabFileName = "Vocab.txt"; // Name of your vocabulary file

    // Get canvas and context
    const canvas = document.getElementById('pinballCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const marblesLeftEl = document.getElementById('marblesLeft');
    const scoreEl = document.getElementById('score');
    const resetButton = document.getElementById('resetButton');

    // Word list UL elements
    const correctWordsUl = document.getElementById('correctWordsUl');
    const incorrectWordsUl = document.getElementById('incorrectWordsUl');

    // Quiz Modal Elements
    const quizModal = document.getElementById('quizModal');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizAnswerInput = document.getElementById('quizAnswerInput');
    const submitAnswerButton = document.getElementById('submitAnswerButton');
    const closeQuizButton = document.getElementById('closeQuizButton');
    const quizMessageEl = document.getElementById('quizMessage');


    // Game settings
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MARBLE_RADIUS = 8;
    const PEG_RADIUS = 4;
    const GRAVITY = 0.15;
    const BOUNCE_FACTOR = 0.65;
    const LAUNCH_AREA_HEIGHT = 80; // Height of the area where the plunger operates
    const PLUNGER_WIDTH = 20;
    const PLUNGER_HEIGHT = 70; // Visual height of the plunger
    const MAX_PULL_DISTANCE = 60; // How far the plunger can be pulled
    const INITIAL_MARBLES = 5;
    const HOLE_ANIMATION_DURATION = 300; // ms for hole light-up/enlarge effect

    // Set canvas dimensions
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Game state variables
    let marbles = [];
    let pegs = [];
    let holes = [];
    let playerMarbles; 
    let score;
    let currentMarble = null; // The marble currently in the plunger, or null
    let isDraggingPlunger = false;
    let plungerPullDistance = 0;
    let gameLoopId;
    let isQuizModeActive = false;
    let currentQuizQuestionObj = null;
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let needsNewMarbleInPlunger = false; // Flag to indicate if a new marble should be loaded
    let quizQuestions = []; // Array to hold vocabulary questions

    // --- Audio Setup (Tone.js) ---
    let audioContextStarted = false;
    let pegHitSynth = null;
    let holeHitSynth = null;

    function initializeAudio() {
        if (typeof Tone !== 'undefined') {
            pegHitSynth = new Tone.MembraneSynth({
                pitchDecay: 0.008,
                octaves: 2,
                envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
                volume: -12 
            }).toDestination();

            holeHitSynth = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                volume: -6
            }).toDestination();
            console.log("Audio synthesizers initialized.");
        } else {
            console.warn("Tone.js is not loaded. Sound effects will be disabled.");
        }
    }
    initializeAudio(); // Initialize audio components when script loads


    // Plunger properties
    const plunger = {
        x: CANVAS_WIDTH - PLUNGER_WIDTH - 15, // Positioned on the right side
        baseY: CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT + (LAUNCH_AREA_HEIGHT - PLUNGER_HEIGHT) / 2, // Base Y position
        width: PLUNGER_WIDTH,
        height: PLUNGER_HEIGHT,
        color: '#4a3b31' // Dark brown color for plunger
    };
    plunger.y = plunger.baseY; // Current Y position, changes during drag

    // Hardcoded vocabulary content as a fallback
    const hardcodedVocabFileContent = `Is it true that humans are naturally born with the (a)________________ to learn a language?:-ability;-0.5
My college in Japan offers a six-month study (a)________________ program in California.:-abroad;-0.5
The missing child was found (a)________________ from home, but safe.:-absent;-0.3
The (a)________________ of rain for many months caused a serious drought.:-absence;-0.3
This is an (a)________________ disaster! We need to evacuate immediately!:-absolute;-0.7
The professor's explanation was so clear that the complex theory became (a)________________ understandable.:-absolutely;-0.7
The sponge can (a)________________ a lot of water.:-absorb;-0.4
His research paper was too (a)________________ and difficult for most people to understand.:-abstract;-0.6
Putting a child in a cage is a form of child (a)________________.:-abuse;-0.8
She received many (a)________________ awards for her work in science.:-academic;-0.5
The university is famous for its high (a)________________ standards.:-academy;-0.5
A clue that ends with the placeholder (a)________________:-endswithplaceholder;-0.2
A clue where textPart2 is the placeholder (a)________________ (a)________________:-placeholderastwo;-0.3
A clue with text after first placeholder then another placeholder (a)________________ text then (a)________________:-textandplaceholder;-0.4`;


    /**
     * Parses the vocabulary data string into an array of question objects.
     * Each object contains textPart1, textPart2, answer, foundPlaceholderText, and clueForDisplayIfNoPlaceholder.
     * @param {string} dataString - The raw string data from the vocab file.
     * @returns {Array<Object>} An array of parsed question objects.
     */
    function parseVocabData(dataString) {
    const lines = dataString.trim().split('\n');
    const parsedQuestions = [];
    // Regex to find placeholders like (a)_____, (b)_____, (n)____________
    // It looks for: ( + a letter + ) + 5 or more underscores
    const pedagogicalPlaceholderRegex = /\(([a-zA-Z])\)_{5,}/;
    const potentialSuffixDelimiter = "(a)________________"; // A common suffix to check for

    lines.forEach(line => {
        if (line.trim() === "") return; // Skip empty lines
        const rawParts = line.split(':-'); // Split clue from answer block
        if (rawParts.length >= 2) {
            let clueText = rawParts[0]; // The full clue part
            const answer = rawParts[1].split(';')[0].trim(); // Get the answer, ignore difficulty for now

            let textPart1 = ""; // Text before the identified pedagogical blank
            let textPart2 = ""; // Text after the identified pedagogical blank
            let actualPedagogicalPlaceholder = null; // Stores the found "(x)_____" string
            let displayClue = clueText; // The version of the clue text to be used if no ped. placeholder found

            const match = clueText.match(pedagogicalPlaceholderRegex);

            if (match) {
                // A pedagogical placeholder like (a)_____ or (n)_____ was found
                actualPedagogicalPlaceholder = match[0]; // The matched string, e.g., "(a)_________"
                const placeholderIndex = match.index;
                textPart1 = clueText.substring(0, placeholderIndex);
                textPart2 = clueText.substring(placeholderIndex + actualPedagogicalPlaceholder.length);
            } else {
                // No specific pedagogical placeholder like (x)_____ was found by the regex.
                // This might mean the clue doesn't use one, or (a)________________ was just a suffix.
                // If (a)________________ was a suffix, we should remove it from the displayClue.
                if (clueText.endsWith(potentialSuffixDelimiter)) {
                    displayClue = clueText.substring(0, clueText.length - potentialSuffixDelimiter.length);
                }
                // In this 'else' case, textPart1 will effectively be the displayClue, and textPart2 empty,
                // as there's no defined "before" and "after" for a pedagogical placeholder.
                textPart1 = displayClue; // Use the (potentially suffix-stripped) clue
                                        // textPart2 remains empty
            }

            parsedQuestions.push({
                textPart1: textPart1.trim(),
                textPart2: textPart2.trim(),
                answer: answer,
                // This new property will hold the actual placeholder string found, e.g., "(a)____" or "(n)____"
                foundPlaceholderText: actualPedagogicalPlaceholder,
                // This will hold the clue text to display if no specific placeholder was extracted
                clueForDisplayIfNoPlaceholder: displayClue.trim()
            });
        } else {
            console.warn("Skipping malformed vocab line:", line);
        }
    });
    return parsedQuestions;
}

    /**
     * Loads vocabulary from an external file or uses hardcoded content if loading fails.
     */
    async function loadVocabulary() {
        if (useExternalVocabFile) {
            try {
                const response = await fetch(vocabFileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} when fetching ${vocabFileName}`);
                }
                const dataString = await response.text();
                console.log("Successfully loaded vocab from:", vocabFileName);
                quizQuestions = parseVocabData(dataString);
            } catch (error) {
                console.warn("Could not load external vocab file. Error:", error, "Falling back to hardcoded vocabulary.");
                quizQuestions = parseVocabData(hardcodedVocabFileContent);
            }
        } else {
            console.log("Using hardcoded vocabulary.");
            quizQuestions = parseVocabData(hardcodedVocabFileContent);
        }
        // Ensure there's at least one question to prevent errors
        if (quizQuestions.length === 0) {
            console.error("No quiz questions loaded! Check vocab data source and format. Using a default question.");
             quizQuestions = parseVocabData("This is a default question (a)________________ if loading fails.:-default;-0.1");
        }
    }

    /**
     * Initializes or resets the game state.
     */
    async function initGame() {
        await loadVocabulary(); // Load vocabulary first

        playerMarbles = INITIAL_MARBLES;
        score = 0;
        marbles = []; // Clear existing marbles
        currentMarble = null;
        isDraggingPlunger = false;
        plungerPullDistance = 0;
        isQuizModeActive = false;
        quizModal.style.display = 'none'; // Hide quiz modal
        correctAnswersCount = 0;
        incorrectAnswersCount = 0;
        needsNewMarbleInPlunger = true; // Ready for the first marble

        // Clear word lists
        correctWordsUl.innerHTML = '';
        incorrectWordsUl.innerHTML = '';

        updateUI(); // Update score and marbles left display
        setupBoard(); // Set up pegs and holes

        if (gameLoopId) cancelAnimationFrame(gameLoopId); // Stop previous game loop if any
        gameLoop(); // Start the game loop
    }

    /**
     * Sets up the pinball board with pegs and holes.
     */
    function setupBoard() {
        pegs = [];
        holes = [];
        const rows = 13; // Number of peg rows
        const cols = 8;  // Max pegs per row (for even rows)
        const xSpacing = (CANVAS_WIDTH - 40) / cols; // Horizontal spacing between pegs
        const ySpacing = (CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 180) / rows; // Vertical spacing
        const xOffset = 20; // Starting X offset for pegs

        // Define a clear rectangular area for the marble's launch path (no pegs here)
        const marbleStartX = plunger.x + PLUNGER_WIDTH / 2;
        const marbleStartY = plunger.baseY - MARBLE_RADIUS - 5;
        const clearRectX1 = marbleStartX - 150; // Left boundary of clear area
        const clearRectX2 = marbleStartX + MARBLE_RADIUS + 20; // Right boundary
        const clearRectY1 = marbleStartY - 300; // Top boundary
        const clearRectY2 = CANVAS_HEIGHT;      // Bottom boundary (extends to bottom)


        // Create pegs in a staggered grid pattern
        for (let i = 0; i < rows; i++) {
            const numColsThisRow = (i % 2 === 0) ? cols : cols - 1; // Staggered rows
            for (let j = 0; j < numColsThisRow; j++) {
                let pegX = (j * xSpacing) + xOffset;
                if (i % 2 !== 0) { // Offset odd rows for staggering
                    pegX += xSpacing / 2;
                }
                const pegY = 90 + i * ySpacing; // Start pegs a bit down from the top

                // Check if the peg is within the clear launch area
                let skipPeg = false;
                if (pegX > clearRectX1 && pegX < clearRectX2 &&
                    pegY > clearRectY1 && pegY < clearRectY2) {
                    skipPeg = true;
                }

                // Add peg if it's not in the clear area and within canvas bounds
                if (!skipPeg && pegX + PEG_RADIUS < CANVAS_WIDTH - xOffset && pegX - PEG_RADIUS > xOffset) {
                     pegs.push({ x: pegX, y: pegY, radius: PEG_RADIUS, color: '#704214' }); // Dark wood color
                }
            }
        }
        
        // Create score holes at the bottom
        const holeValues = [25, 50, -5, 10, 5, 15, -10]; // Score values for each hole
        const baseHoleRadius = 19; 
        const holeY = CANVAS_HEIGHT - 60; // Y position of holes
        const numHoles = holeValues.length;
        const holeSpacing = (CANVAS_WIDTH - 40) / (numHoles); // Space them out
        const firstHoleX = 20 + holeSpacing / 2; // X position of the first hole

        for (let i = 0; i < numHoles; i++) {
            holes.push({
                x: firstHoleX + i * holeSpacing,
                y: holeY,
                baseRadius: baseHoleRadius, 
                baseColor: `hsl(${20 + i * (300 / numHoles)}, 70%, 55%)`, // Varying colors
                value: holeValues[i],
                hitAnimationEndTime: 0 // For hit animation
            });
        }
    }

    /**
     * Updates the displayed score and marbles left.
     */
    function updateUI() {
        marblesLeftEl.textContent = playerMarbles;
        scoreEl.textContent = score;
    }

    /**
     * Creates a new marble in the plunger area if marbles are available.
     * @returns {boolean} True if a marble was created, false otherwise.
     */
    function createMarble() {
        if (playerMarbles > 0) {
            playerMarbles--; // Use one marble
            currentMarble = {
                x: plunger.x + PLUNGER_WIDTH / 2,
                y: plunger.baseY - MARBLE_RADIUS - 5, // Position above the plunger
                radius: MARBLE_RADIUS,
                vx: 0, vy: 0, // Initial velocity
                color: `hsl(${Math.random() * 360}, 85%, 65%)`, // Random bright color
                isActive: false, // Not yet launched
                hasHitPeg: false // Track if marble hit any peg (for penalty if it goes off bottom)
            };
            marbles.push(currentMarble);
            updateUI();
            return true;
        }
        updateUI(); // Still update UI in case marbles hit 0
        return false;
    }

    /**
     * Launches the current marble with a given power.
     * @param {number} power - The launch power.
     */
    function launchMarble(power) {
        if (currentMarble && !currentMarble.isActive) {
            currentMarble.isActive = true;
            // Launch angle with some randomness
            const baseAngle = -Math.PI * (2/3); // ~120 degrees upwards and to the left
            const randomFactor = (Math.random() * Math.PI / 18) - (Math.PI / 36); // +/- 5 degrees
            const angle = baseAngle + randomFactor;
            
            currentMarble.vx = power * Math.cos(angle);
            currentMarble.vy = power * Math.sin(angle);
            currentMarble = null; // Marble is launched, plunger is now empty
        }
    }

    /**
     * Draws the plunger and its housing.
     */
    function drawPlunger() {
        // Draw plunger housing (decorative)
        ctx.fillStyle = '#a0522d'; // Lighter brown for housing
        ctx.beginPath();
        ctx.moveTo(plunger.x - 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x - 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15); // Angled top
        ctx.lineTo(plunger.x - 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15); // Angled top
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#5d4037'; // Darker outline
        ctx.lineWidth = 2;
        ctx.stroke();

        // Draw the plunger itself
        ctx.fillStyle = plunger.color;
        const currentPlungerY = plunger.baseY + plungerPullDistance;
        const currentPlungerHeight = plunger.height - plungerPullDistance; // Plunger compresses visually
        ctx.fillRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#332a23'; // Very dark outline for plunger
        ctx.strokeRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);

        // Draw a simple spring visual
        ctx.strokeStyle = '#777'; // Grey for spring
        ctx.lineWidth = 3;
        const springTopY = plunger.baseY + plunger.height; // Top of spring (fixed)
        const springBottomY = currentPlungerY + currentPlungerHeight; // Bottom of spring (moves with plunger)
        if (springBottomY > springTopY) { // Only draw if spring is stretched/visible
            for(let i=0; i < 4; i++) { // Draw a few coils
                ctx.beginPath();
                const yPos = springTopY + (i * (springBottomY - springTopY) / 4);
                ctx.moveTo(plunger.x + PLUNGER_WIDTH/2 - 6, yPos);
                ctx.lineTo(plunger.x + PLUNGER_WIDTH/2 + 6, yPos + (springBottomY - springTopY) / 8);
                ctx.stroke();
            }
        }
    }

    /**
     * Draws all marbles on the canvas.
     */
    function drawMarbles() {
        marbles.forEach(marble => {
            if (marble) { // Check if marble exists (it might have been removed)
                ctx.beginPath();
                ctx.arc(marble.x, marble.y, marble.radius, 0, Math.PI * 2);
                ctx.fillStyle = marble.color;
                ctx.fill();
                if (marble.isActive) { // Slightly different outline for active marbles
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
            }
        });
    }

    /**
     * Draws all pegs on the canvas.
     */
    function drawPegs() {
        pegs.forEach(peg => {
            ctx.beginPath();
            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
            ctx.fillStyle = peg.color;
            ctx.fill();
            ctx.strokeStyle = '#503010'; // Darker outline for pegs
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    /**
     * Draws all score holes on the canvas, with animation.
     */
    function drawHoles() {
        const now = Date.now();
        holes.forEach(hole => {
            let currentRadius = hole.baseRadius;
            let currentColor = hole.baseColor;
            let showHighlight = false;

            // Animate hole on hit
            if (now < hole.hitAnimationEndTime) {
                const timeRemaining = hole.hitAnimationEndTime - now;
                const progress = 1 - (timeRemaining / HOLE_ANIMATION_DURATION); 
                const scaleFactor = 1 + 0.2 * Math.sin(progress * Math.PI); // Pulse effect
                currentRadius = hole.baseRadius * scaleFactor;
                currentColor = '#FFFF99'; // Highlight color
                showHighlight = true;
            }

            // Draw outer part of the hole (darker)
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
            ctx.fill();

            // Draw inner part of the hole (colored)
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius - 3, 0, Math.PI * 2); // Slightly smaller inner circle
            ctx.fillStyle = currentColor;
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke(); 

            // Draw score value text
            ctx.fillStyle = showHighlight ? '#333' : 'white'; // Text color contrast
            let fontSize = 12;
            if (Math.abs(hole.value) >= 100 || (hole.value < 0 && Math.abs(hole.value) >= 10)) fontSize = 10;
            else if (Math.abs(hole.value) >= 10) fontSize = 11; 
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(hole.value, hole.x, hole.y);
        });
    }

    /**
     * Updates the position and physics of active marbles.
     */
    function updateMarbles() {
        for (let i = marbles.length - 1; i >= 0; i--) { // Iterate backwards for safe removal
            const marble = marbles[i];
            if (!marble || !marble.isActive) continue; // Skip inactive or null marbles

            // Apply gravity and update position
            marble.vy += GRAVITY;
            marble.x += marble.vx;
            marble.y += marble.vy;

            // Wall collisions
            if (marble.x - marble.radius < 0) { // Left wall
                marble.x = marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            } else if (marble.x + marble.radius > CANVAS_WIDTH) { // Right wall
                marble.x = CANVAS_WIDTH - marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            }
            if (marble.y - marble.radius < 0 && marble.vy < 0) { // Top wall (only if moving up)
                marble.y = marble.radius;
                marble.vy *= -BOUNCE_FACTOR;
            }

            // Peg collisions
            pegs.forEach(peg => {
                const dx = marble.x - peg.x;
                const dy = marble.y - peg.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadii = marble.radius + peg.radius;

                if (distance < combinedRadii) {
                    marble.hasHitPeg = true; 
                    const overlap = combinedRadii - distance;
                    const angle = Math.atan2(dy, dx);

                    // Resolve overlap by pushing marble back slightly
                    marble.x += Math.cos(angle) * overlap * 0.5; 
                    marble.y += Math.sin(angle) * overlap * 0.5;

                    // Collision response (reflection)
                    const normalX = dx / distance;
                    const normalY = dy / distance;
                    const dotProduct = marble.vx * normalX + marble.vy * normalY;
                    marble.vx = (marble.vx - 2 * dotProduct * normalX) * BOUNCE_FACTOR;
                    marble.vy = (marble.vy - 2 * dotProduct * normalY) * BOUNCE_FACTOR;
                    
                    // Add slight random spin for less predictable bounces
                    marble.vx += (Math.random() - 0.5) * 0.3; 
                    marble.vy += (Math.random() - 0.5) * 0.3;

                    if (pegHitSynth && audioContextStarted) {
                        // --- MODIFIED: Schedule slightly in the future ---
                        pegHitSynth.triggerAttackRelease("C2", "8n", "+0.01"); // Increased delay
                    }
                }
            });

            // Hole collisions
            let marbleRemoved = false;
            holes.forEach(hole => {
                const dx = marble.x - hole.x;
                const dy = marble.y - hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hole.baseRadius) { // Marble falls into a hole
                    score += hole.value;
                    marbles.splice(i, 1); // Remove marble
                    marbleRemoved = true;
                    updateUI();

                    hole.hitAnimationEndTime = Date.now() + HOLE_ANIMATION_DURATION; // Trigger animation
                    if (holeHitSynth && audioContextStarted) {
                        let freq; // Determine sound frequency based on score
                        if (hole.value > 0) {
                            freq = 200 + hole.value * 8; 
                        } else if (hole.value < 0) {
                            freq = 150 + hole.value * 6; 
                        } else { 
                            freq = 180;
                        }
                        freq = Math.max(80, Math.min(freq, 1200)); // Clamp frequency
                        // --- MODIFIED: Schedule slightly in the future ---
                        holeHitSynth.triggerAttackRelease(freq, "8n", "+0.01"); // Increased delay
                    }
                    // Check if a new marble is needed
                    if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                        needsNewMarbleInPlunger = true;
                    }
                    return; // Exit hole check for this marble as it's removed
                }
            });

            if (marbleRemoved) continue; // Skip to next marble if this one was removed

            // Marble goes off bottom of the screen
            if (marble.y - marble.radius > CANVAS_HEIGHT) {
                if (!marble.hasHitPeg) { // Penalty if marble didn't hit any pegs
                    score = Math.max(0, score - 1); // Lose 1 point, don't go below 0
                }
                marbles.splice(i, 1); // Remove marble
                updateUI();
                // Check if a new marble is needed
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                    needsNewMarbleInPlunger = true;
                }
            }
        }
    }

    /**
     * Main game loop. Clears canvas, draws elements, updates game state.
     */
    function gameLoop() {
        if (isQuizModeActive) { // Pause game loop if quiz is active
            return; 
        }
        // Clearing the canvas is usually done here if the background is drawn by JavaScript.
        // However, since the background is now a CSS property of the canvas element itself,
        // ctx.clearRect will clear drawings on top of the CSS background.
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 

        drawPlunger();
        drawPegs();
        drawHoles(); 
        drawMarbles();

        // Load a new marble into the plunger if needed
        if (needsNewMarbleInPlunger && playerMarbles > 0 && !currentMarble && !isQuizModeActive) {
            if (!marbles.some(m => m && m.isActive)) { // Ensure no other marbles are active
                createMarble();
                needsNewMarbleInPlunger = false;
            }
        }
        
        // Update active marbles
        if (marbles.some(m => m && m.isActive)) { 
             updateMarbles();
        }

        // Check for game over condition (no marbles left and no active marbles)
        if (playerMarbles <= 0 && !marbles.some(m => m && m.isActive) && !currentMarble) {
            enterQuizMode(); // Transition to quiz mode
        } else {
            gameLoopId = requestAnimationFrame(gameLoop); // Continue loop
        }
    }

    /**
     * Displays the game over message on the canvas.
     */
    function displayGameOverMessage() {
        if(gameLoopId) cancelAnimationFrame(gameLoopId); // Stop the game loop
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; // Semi-transparent overlay
        ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 120);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 15);
        ctx.font = '20px Arial';
        ctx.fillText('Final Score: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    }
    
    /**
     * Enters quiz mode when player runs out of marbles.
     */
    function enterQuizMode() {
        if (isQuizModeActive) return; 
        if (quizQuestions.length === 0) {
            console.log("No quiz questions available, ending game.");
            displayGameOverMessage(); 
            return;
        }
        isQuizModeActive = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId); // Pause game

        loadNewQuizQuestion();
        quizModal.style.display = 'flex'; // Show the modal
        quizAnswerInput.value = '';
        quizAnswerInput.focus();
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    /**
     * Loads and displays a new random quiz question.
     * Formats the question string to bold the placeholder.
     */
    function loadNewQuizQuestion() {
        if (quizQuestions.length === 0) {
            quizQuestionEl.textContent = "No more questions available.";
            submitAnswerButton.disabled = true;
            return;
        }
        const randomIndex = Math.floor(Math.random() * quizQuestions.length);
        currentQuizQuestionObj = quizQuestions[randomIndex];

        const part1FromParse = currentQuizQuestionObj.textPart1;
        const part2FromParse = currentQuizQuestionObj.textPart2;
        const identifiedPlaceholder = currentQuizQuestionObj.foundPlaceholderText;
        const fallbackClueDisplay = currentQuizQuestionObj.clueForDisplayIfNoPlaceholder;

        let finalQuestionHtml = "";

        if (identifiedPlaceholder) {
            // A specific pedagogical placeholder (e.g., "(a)_____", "(n)_____") was found.
            const boldedIdentifiedPlaceholder = `<b>${identifiedPlaceholder}</b>`;
            let questionParts = [];
            if (part1FromParse && part1FromParse.length > 0) questionParts.push(part1FromParse);
            questionParts.push(boldedIdentifiedPlaceholder);
            if (part2FromParse && part2FromParse.length > 0) questionParts.push(part2FromParse);
            finalQuestionHtml = questionParts.join(" ");
        } else {
            // No specific pedagogical placeholder was identified. Display the fallback.
            finalQuestionHtml = fallbackClueDisplay;
        }

        quizQuestionEl.innerHTML = finalQuestionHtml; // Use innerHTML to render bold tag
        quizAnswerInput.value = '';
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
        submitAnswerButton.disabled = false; // Enable submit button
    }

    /**
     * Adds a word to the correct or incorrect word list in the UI.
     * @param {string} word - The word to add.
     * @param {HTMLElement} listElement - The UL element to add to.
     * @param {boolean} isCorrect - True if the answer was correct.
     */
    function addWordToList(word, listElement, isCorrect) {
        const li = document.createElement('li');
        if (isCorrect) {
            correctAnswersCount++;
            li.textContent = `${correctAnswersCount}. ${word}`;
        } else {
            incorrectAnswersCount++;
            li.textContent = `${incorrectAnswersCount}. ${word}`; // For incorrect, 'word' is the correct answer
        }
        listElement.appendChild(li);
        listElement.scrollTop = listElement.scrollHeight; // Auto-scroll to bottom
    }

    /**
     * Handles the submission of a quiz answer.
     */
    function handleSubmitQuizAnswer() {
        if (!currentQuizQuestionObj || !isQuizModeActive) return;
        const userAnswer = quizAnswerInput.value.trim();
        const correctAnswer = currentQuizQuestionObj.answer;

        if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
            quizMessageEl.textContent = 'Correct! You get 1 marble.';
            quizMessageEl.className = 'quizCorrect';
            playerMarbles++; // Award a marble
            updateUI();
            addWordToList(correctAnswer, correctWordsUl, true);
            submitAnswerButton.disabled = true; 
            setTimeout(() => { // Load next question after a delay
                loadNewQuizQuestion(); 
                if (quizAnswerInput.offsetParent !== null) quizAnswerInput.focus(); // Focus if modal is visible
            }, 1500);
        } else {
            quizMessageEl.textContent = 'Incorrect. Try another question!';
            quizMessageEl.className = 'quizIncorrect';
            addWordToList(correctAnswer, incorrectWordsUl, false); // Add correct answer to incorrect list
            submitAnswerButton.disabled = true;
            setTimeout(() => { // Load next question
                loadNewQuizQuestion();
                 if (quizAnswerInput.offsetParent !== null) quizAnswerInput.focus();
            }, 1500);
        }
    }
    
    /**
     * Handles closing the quiz modal.
     */
    function handleCloseQuiz() {
        quizModal.style.display = 'none';
        isQuizModeActive = false;

        if (playerMarbles <= 0 && !currentMarble && !marbles.some(m=> m && m.isActive)) {
            // If still no marbles after quiz, game over
            displayGameOverMessage();
        } else {
            // If marbles were gained, or game wasn't over, resume
            if (playerMarbles > 0 && !currentMarble && !marbles.some(m => m && m.isActive)) {
                 needsNewMarbleInPlunger = true; // Prepare a new marble
            }
            gameLoop(); // Resume game loop
        }
    }

    // --- Event Listeners for Plunger Interaction (Mouse and Touch) ---
    let startInputY; // Generic variable for starting Y of drag (either mouse or touch)

    /**
     * Common handler for mousedown and touchstart on the plunger.
     * @param {number} clientX - The clientX coordinate of the input.
     * @param {number} clientY - The clientY coordinate of the input.
     */
    async function handlePlungerStart(clientX, clientY) {
        if (isQuizModeActive) return;

        // Start audio context on first user interaction
        if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
            try {
                await Tone.start();
                audioContextStarted = true;
                console.log('Audio context started successfully by user interaction.');
            } catch (error) {
                console.error('Failed to start audio context on user interaction:', error);
            }
        }

        const rect = canvas.getBoundingClientRect();
        const inputX = clientX - rect.left;
        const inputY = clientY - rect.top;

        // Check if the input is within the plunger's clickable area
        if (inputX >= plunger.x && inputX <= plunger.x + plunger.width &&
            inputY >= plunger.baseY && inputY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) { // Allow clicking slightly below for dragging
            
            // If no marble in plunger, try to create one
            if (!currentMarble) { 
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive)) { 
                    createMarble(); 
                } else {
                    return; // No marbles to create or another is active
                }
            }

            // If marble is ready in plunger, start dragging
            if (currentMarble && !currentMarble.isActive) { 
                isDraggingPlunger = true;
                startInputY = inputY; // Record the starting Y position of the drag
                plungerPullDistance = 0; 
            }
        }
    }

    /**
     * Common handler for mousemove and touchmove when dragging the plunger.
     * @param {number} clientY - The clientY coordinate of the input.
     */
    function handlePlungerMove(clientY) {
        if (isQuizModeActive || !isDraggingPlunger) return;
        
        const rect = canvas.getBoundingClientRect();
        const inputY = clientY - rect.top;
        
        let pull = inputY - startInputY; // Calculate pull distance from start
        if (pull < 0) pull = 0; // Don't allow pulling upwards beyond base
        if (pull > MAX_PULL_DISTANCE) pull = MAX_PULL_DISTANCE; // Cap pull distance
        plungerPullDistance = pull;
    }

    /**
     * Common handler for mouseup and touchend to launch the marble.
     */
    function handlePlungerEnd() {
        if (isQuizModeActive || !isDraggingPlunger) return;
        isDraggingPlunger = false;
        if (plungerPullDistance > 5) { // Only launch if pulled a minimum distance
            const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4; // Calculate power
            launchMarble(launchPower);
        }
        plungerPullDistance = 0; // Reset pull distance
    }


    // Mouse Event Listeners
    canvas.addEventListener('mousedown', async (e) => { 
        handlePlungerStart(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousemove', (e) => {
        // Only handle if a mouse-initiated drag is in progress
        if (isDraggingPlunger && e.buttons === 1) { // e.buttons === 1 checks if left mouse button is held
             handlePlungerMove(e.clientY);
        } else if (isDraggingPlunger && e.buttons !== 1) {
            // If mouse button was released outside canvas but drag was active
            handlePlungerEnd();
        }
    });

    canvas.addEventListener('mouseup', () => {
        // Only handle if a mouse-initiated drag was in progress
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    canvas.addEventListener('mouseleave', () => { 
        // If mouse leaves canvas while dragging, consider it a launch
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    // Touch Event Listeners
    canvas.addEventListener('touchstart', async (e) => {
        if (e.touches.length > 0) {
            // Important: Prevent default touch action (like scrolling) if the touch is on the plunger
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
             if (touchX >= plunger.x && touchX <= plunger.x + plunger.width &&
                touchY >= plunger.baseY && touchY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) {
                e.preventDefault(); 
            }
            handlePlungerStart(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false }); // passive: false is needed to allow preventDefault

    canvas.addEventListener('touchmove', (e) => {
        if (isDraggingPlunger && e.touches.length > 0) {
            e.preventDefault(); // Prevent scrolling while dragging plunger
            handlePlungerMove(e.touches[0].clientY);
        }
    }, { passive: false }); // passive: false is needed to allow preventDefault

    canvas.addEventListener('touchend', (e) => {
        // touchend doesn't have e.touches for the ended touch, but isDraggingPlunger handles state
        if (isDraggingPlunger) {
             handlePlungerEnd();
        }
    });

    canvas.addEventListener('touchcancel', (e) => { // Handle if touch is interrupted (e.g., by system UI)
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    // Quiz Event Listeners
    submitAnswerButton.addEventListener('click', handleSubmitQuizAnswer);
    quizAnswerInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            handleSubmitQuizAnswer();
        }
    });
    closeQuizButton.addEventListener('click', handleCloseQuiz);

    // Reset button functionality
    resetButton.addEventListener('click', initGame);

    // Start the game automatically on load
    // Ensure DOM is fully loaded before starting, especially if script is in <head>
    // If script is at the end of <body>, this is generally fine.
    // For robustness: window.addEventListener('DOMContentLoaded', initGame);
    initGame(); 

</script>

</body>
</html>
