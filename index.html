<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Andy's Pinball</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic styling for the page */
        body {
            font-family: 'Inter', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10 and IE 11 */
            user-select: none; /* Standard syntax */
        }
        h1 {
            color: #6a4f40;
            margin-bottom: 10px;
        }

        /* Main game area layout */
        #gameContainer {
            display: flex;
            flex-direction: row; /* Arrange items horizontally */
            align-items: flex-start; /* Align items to the top */
            justify-content: center; /* Center the whole container */
            gap: 15px; /* Space between canvas and word lists */
            margin-top: 10px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }

        /* Word list styling */
        .wordList {
            width: 120px; /* Fixed width for word lists */
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            height: calc(600px - 22px); /* Match canvas height minus padding/border */
            overflow-y: auto; /* Scroll if content overflows */
            font-size: 0.9em;
        }
        .wordList h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            color: #5d4037;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .wordList ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .wordList ul li {
            padding: 3px 0;
            border-bottom: 1px dashed #eee;
            word-wrap: break-word; /* Ensure long words break */
        }
        .wordList ul li:last-child {
            border-bottom: none;
        }

        /* Canvas styling */
        canvas {
            border: 3px solid #4a3b31;
            display: block;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            touch-action: none; /* Important for preventing default touch actions like scrolling on the canvas */
            
            /* Using a placeholder as the original background image is not available */
            background-color: #deb887; /* Fallback color */
            background-image: url('https://placehold.co/400x600/deb887/4a3b31?text=Pinball+Board');
            background-size: cover; /* Cover the entire canvas */
            background-repeat: no-repeat; /* Do not repeat the image */
            background-position: center center; /* Center the image */
        }
        /* Controls container styling */
        #controls {
            margin-top: 20px;
            padding: 15px 20px;
            background-color: #fff8e1;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        #controls p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #5d4037;
        }
        /* Button styling */
        button {
            padding: 12px 20px;
            font-size: 1.05em;
            background-color: #c87638;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        button:hover {
            background-color: #b5652c;
            transform: translateY(-1px);
        }
        button:active {
            background-color: #a05420;
            transform: translateY(0px);
        }
        /* Instructions styling */
        #instructions {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.95em;
            color: #666;
            max-width: 400px; /* Max width for instructions below canvas */
            text-align: center;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }


        /* Quiz Modal Styling */
        #quizModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; /* Initially hidden */
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #quizContent {
            background-color: #fff8e1;
            padding: 25px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 450px;
            border: 2px solid #c87638;
        }
        #quizContent h2 {
            color: #6a4f40;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #quizQuestion {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
        #quizAnswerInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: calc(100% - 22px); /* Account for padding */
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #quizMessage {
            margin-top: 10px;
            font-weight: bold;
            min-height: 1.2em; /* Prevent layout shift */
        }
        .quizCorrect { color: green; }
        .quizIncorrect { color: red; }
        #quizButtons button {
            margin: 5px;
        }

        /* --- ADDED: On-screen error log styling --- */
        #errorLog {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 120px; /* Increased height a bit */
            overflow-y: scroll;
            background-color: rgba(255, 0, 0, 0.7); /* Red background for errors */
            color: white;
            font-size: 11px; /* Slightly larger for readability */
            z-index: 20000; /* Ensure it's on top */
            padding: 5px;
            box-sizing: border-box;
            display: none; /* Hidden by default */
        }
        #errorLog div { /* Style for individual error messages */
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }
        #errorLog div:last-child {
            border-bottom: none;
        }

    </style>
</head>
<body>

    <h1>Andy's Pinball</h1>

    <div id="gameContainer">
        <div id="incorrectWordsList" class="wordList">
            <h3>Incorrect Guesses (Correct Answers)</h3>
            <ul id="incorrectWordsUl"></ul>
        </div>
        <canvas id="pinballCanvas"></canvas>
        <div id="correctWordsList" class="wordList">
            <h3>Correct Answers</h3>
            <ul id="correctWordsUl"></ul>
        </div>
    </div>

    <div id="controls">
        <p>Marbles Left: <span id="marblesLeft">0</span></p>
        <p>Score: <span id="score">0</span></p>
        <button id="resetButton">New Game</button>
    </div>
    <div id="instructions">
        <p>Click/Tap and drag the plunger (bottom right) downwards to set power, then release to launch.</p>
        <p style="font-size:0.8em; color: #777;">(Note: "Marbles Left" shows your reserve. One is used when loaded into the plunger.)</p>
    </div>

    <div id="quizModal">
        <div id="quizContent">
            <h2>Quiz Time!</h2>
            <p id="quizQuestion">Question text will appear here.</p>
            <input type="text" id="quizAnswerInput" placeholder="Your answer">
            <div id="quizButtons">
                <button id="submitAnswerButton">Submit Answer</button>
                <button id="closeQuizButton">Close Quiz</button>
            </div>
            <p id="quizMessage"></p>
        </div>
    </div>

    <div id="errorLog"></div>

<script>
    // --- CONFIGURATION ---
    const useExternalVocabFile = false; // Set to false to use hardcoded vocab
    const vocabFileName = "Vocab.txt"; 

    // Get canvas and context
    const canvas = document.getElementById('pinballCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const marblesLeftEl = document.getElementById('marblesLeft');
    const scoreEl = document.getElementById('score');
    const resetButton = document.getElementById('resetButton');

    const correctWordsUl = document.getElementById('correctWordsUl');
    const incorrectWordsUl = document.getElementById('incorrectWordsUl');

    const quizModal = document.getElementById('quizModal');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizAnswerInput = document.getElementById('quizAnswerInput');
    const submitAnswerButton = document.getElementById('submitAnswerButton');
    const closeQuizButton = document.getElementById('closeQuizButton');
    const quizMessageEl = document.getElementById('quizMessage');
    
    const errorLogDiv = document.getElementById('errorLog');

    // Function to display errors on the screen for better debugging
    function displayErrorOnScreen(message) {
        if (errorLogDiv) {
            errorLogDiv.style.display = 'block'; // Show the log on first error
            const entry = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            entry.textContent = `${time}: ${message}`;
            while (errorLogDiv.children.length > 20) {
                errorLogDiv.removeChild(errorLogDiv.firstChild);
            }
            errorLogDiv.appendChild(entry);
            errorLogDiv.scrollTop = errorLogDiv.scrollHeight; 
        }
        console.error(message); 
    }

    // Global error handler
    window.onerror = function(message, source, lineno, colno, errorObject) {
        let fullMessage = `ERROR: ${message}`;
        if (source) {
            fullMessage += ` at ${source.substring(source.lastIndexOf('/') + 1)}:${lineno}:${colno}`;
        }
        if (errorObject && errorObject.stack) {
            const stackLines = errorObject.stack.split('\n');
            fullMessage += ` | Stack: ${stackLines.slice(0, 3).join('; ')}`; 
        }
        displayErrorOnScreen(fullMessage);
        return false; 
    };


    // Game settings
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MARBLE_RADIUS = 8;
    const PEG_RADIUS = 4;
    const GRAVITY = 0.15;
    const BOUNCE_FACTOR = 0.65;
    const LAUNCH_AREA_HEIGHT = 80; 
    const PLUNGER_WIDTH = 20;
    const PLUNGER_HEIGHT = 70; 
    const MAX_PULL_DISTANCE = 60; 
    const INITIAL_MARBLES = 5;
    const HOLE_ANIMATION_DURATION = 300; 

    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Game state variables
    let marbles = [];
    let pegs = [];
    let holes = [];
    let playerMarbles; 
    let score;
    let currentMarble = null; 
    let isDraggingPlunger = false;
    let plungerPullDistance = 0;
    let gameLoopId;
    let isQuizModeActive = false;
    let currentQuizQuestionObj = null;
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let needsNewMarbleInPlunger = false; 
    let quizQuestions = []; 

    // Audio variables
    let audioContextStarted = false;
    let pegHitSynth = null;
    let holeHitSynth = null;

    // Initialize audio synthesizers using Tone.js
    function initializeAudio() {
        if (typeof Tone !== 'undefined') {
            try {
                pegHitSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.008,
                    octaves: 2,
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
                    volume: -12 
                }).toDestination();

                holeHitSynth = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                    volume: -6
                }).toDestination();
                console.log("Audio synthesizers initialized.");
            } catch(e) {
                displayErrorOnScreen("Error initializing Tone.js synths: " + e.message);
            }
        } else {
            console.warn("Tone.js is not loaded. Sound effects will be disabled.");
        }
    }
    initializeAudio(); 


    // Plunger object definition
    const plunger = {
        x: CANVAS_WIDTH - PLUNGER_WIDTH - 15, 
        baseY: CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT + (LAUNCH_AREA_HEIGHT - PLUNGER_HEIGHT) / 2, 
        width: PLUNGER_WIDTH,
        height: PLUNGER_HEIGHT,
        color: '#4a3b31' 
    };
    plunger.y = plunger.baseY; 

    // Hardcoded vocabulary data as a fallback
    const hardcodedVocabFileContent = `The flight attendant welcomed us (a)________________ the airplane.:-aboard;-1.5
A (z)________________ is a horse with black and white stripes (lines) on its body.:-zebra;-0.5
Is it true that humans are naturally born with the (a)________________ to learn a language?:-ability;-0.5
My college in Japan offers a six-month study (a)________________ program in California.:-abroad;-0.5
The missing child was found (a)________________ from home, but safe.:-absent;-0.3
The (a)________________ of rain for many months caused a serious drought.:-absence;-0.3
This is an (a)________________ disaster! We need to evacuate immediately!:-absolute;-0.7
The professor's explanation was so clear that the complex theory became (a)________________ understandable.:-absolutely;-0.7
The sponge can (a)________________ a lot of water.:-absorb;-0.4
His research paper was too (a)________________ and difficult for most people to understand.:-abstract;-0.6
Putting a child in a cage is a form of child (a)________________.:-abuse;-0.8
She received many (a)________________ awards for her work in science.:-academic;-0.5
The university is famous for its high (a)________________ standards.:-academy;-0.5
A clue that ends with the placeholder (a)________________:-endswithplaceholder;-0.2
A clue where textPart2 is the placeholder (a)________________ (a)________________:-placeholderastwo;-0.3
A clue with text after first placeholder then another placeholder (a)________________ text then (a)________________:-textandplaceholder;-0.4`;


    /**
     * Parses the vocabulary string into a structured array of questions, including the reward value.
     * @param {string} dataString The raw vocabulary data.
     * @returns {Array} An array of question objects.
     */
    function parseVocabData(dataString) {
        const lines = dataString.trim().split('\n');
        const parsedQuestions = [];
        const pedagogicalPlaceholderRegex = /\(([a-zA-Z])\)_{5,}/;
        const potentialSuffixDelimiter = "(a)________________";

        lines.forEach(line => {
            if (line.trim() === "") return;
            const rawParts = line.split(':-');
            if (rawParts.length >= 2) {
                let clueText = rawParts[0];
                const answerParts = rawParts[1].split(';');
                const answer = answerParts[0].trim();
                // Extract the reward value, defaulting to 0.5 if not present
                const rewardValue = answerParts.length > 1 ? Math.abs(parseFloat(answerParts[1])) : 0.5;

                let textPart1 = "";
                let textPart2 = "";
                let actualPedagogicalPlaceholder = null;
                let displayClue = clueText;

                const match = clueText.match(pedagogicalPlaceholderRegex);

                if (match) {
                    actualPedagogicalPlaceholder = match[0];
                    const placeholderIndex = match.index;
                    textPart1 = clueText.substring(0, placeholderIndex);
                    textPart2 = clueText.substring(placeholderIndex + actualPedagogicalPlaceholder.length);
                } else {
                    if (clueText.endsWith(potentialSuffixDelimiter)) {
                        displayClue = clueText.substring(0, clueText.length - potentialSuffixDelimiter.length);
                    }
                    textPart1 = displayClue;
                }

                parsedQuestions.push({
                    textPart1: textPart1.trim(),
                    textPart2: textPart2.trim(),
                    answer: answer,
                    rewardValue: rewardValue, // Store the reward value
                    foundPlaceholderText: actualPedagogicalPlaceholder,
                    clueForDisplayIfNoPlaceholder: displayClue.trim()
                });
            } else {
                console.warn("Skipping malformed vocab line:", line);
            }
        });
        return parsedQuestions;
    }


    // Asynchronously loads vocabulary from a file or uses the hardcoded version
    async function loadVocabulary() {
        if (useExternalVocabFile) {
            try {
                const response = await fetch(vocabFileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} when fetching ${vocabFileName}`);
                }
                const dataString = await response.text();
                console.log("Successfully loaded vocab from:", vocabFileName);
                quizQuestions = parseVocabData(dataString);
            } catch (error) {
                displayErrorOnScreen("Vocab load error: " + error.message + ". Using hardcoded vocab."); 
                quizQuestions = parseVocabData(hardcodedVocabFileContent);
            }
        } else {
            console.log("Using hardcoded vocabulary.");
            quizQuestions = parseVocabData(hardcodedVocabFileContent);
        }
        if (quizQuestions.length === 0) {
             const errMsg = "No quiz questions loaded! Using default.";
             console.error(errMsg);
             displayErrorOnScreen(errMsg);
             quizQuestions = parseVocabData("This is a default question (a)________________ if loading fails.:-default;-0.1");
        }
    }

    // Initializes or resets the game state
    async function initGame() {
        await loadVocabulary(); 

        playerMarbles = INITIAL_MARBLES;
        score = 0;
        marbles = []; 
        currentMarble = null;
        isDraggingPlunger = false;
        plungerPullDistance = 0;
        isQuizModeActive = false;
        quizModal.style.display = 'none'; 
        correctAnswersCount = 0;
        incorrectAnswersCount = 0;
        needsNewMarbleInPlunger = true; 

        correctWordsUl.innerHTML = '';
        incorrectWordsUl.innerHTML = '';

        updateUI(); 
        setupBoard(); 

        if (gameLoopId) cancelAnimationFrame(gameLoopId); 
        gameLoop(); 
    }

    // Sets up the pegs and holes on the game board
    function setupBoard() {
        pegs = [];
        holes = [];
        const rows = 13; 
        const cols = 8;  
        const xSpacing = (CANVAS_WIDTH - 40) / cols; 
        const ySpacing = (CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 180) / rows; 
        const xOffset = 20; 

        // Define a clear area for the marble path from the plunger
        const marbleStartX = plunger.x + PLUNGER_WIDTH / 2;
        const marbleStartY = plunger.baseY - MARBLE_RADIUS - 5;
        const clearRectX1 = marbleStartX - 150; 
        const clearRectX2 = marbleStartX + MARBLE_RADIUS + 20; 
        const clearRectY1 = marbleStartY - 300; 
        const clearRectY2 = CANVAS_HEIGHT;       


        // Create pegs in a grid pattern
        for (let i = 0; i < rows; i++) {
            const numColsThisRow = (i % 2 === 0) ? cols : cols - 1; 
            for (let j = 0; j < numColsThisRow; j++) {
                let pegX = (j * xSpacing) + xOffset;
                if (i % 2 !== 0) { 
                    pegX += xSpacing / 2;
                }
                const pegY = 90 + i * ySpacing; 
                let skipPeg = false;
                // Check if the peg is in the clear area
                if (pegX > clearRectX1 && pegX < clearRectX2 &&
                    pegY > clearRectY1 && pegY < clearRectY2) {
                    skipPeg = true;
                }
                // Add peg if it's not in the clear area and within bounds
                if (!skipPeg && pegX + PEG_RADIUS < CANVAS_WIDTH - xOffset && pegX - PEG_RADIUS > xOffset) {
                     pegs.push({ x: pegX, y: pegY, radius: PEG_RADIUS, color: '#704214' }); 
                }
            }
        }
        
        // Create holes at the bottom of the board
        const holeValues = [25, 50, -5, 10, 5, 15, -10]; 
        const baseHoleRadius = 19; 
        const holeY = CANVAS_HEIGHT - 60; 
        const numHoles = holeValues.length;
        const holeSpacing = (CANVAS_WIDTH - 40) / (numHoles); 
        const firstHoleX = 20 + holeSpacing / 2; 

        for (let i = 0; i < numHoles; i++) {
            holes.push({
                x: firstHoleX + i * holeSpacing,
                y: holeY,
                baseRadius: baseHoleRadius, 
                baseColor: `hsl(${20 + i * (300 / numHoles)}, 70%, 55%)`, 
                value: holeValues[i],
                hitAnimationEndTime: 0 
            });
        }
    }

    // Updates the score and marbles left display
    function updateUI() {
        marblesLeftEl.textContent = playerMarbles;
        scoreEl.textContent = score;
    }

    // Creates a new marble if the player has any left
    function createMarble() {
        if (playerMarbles > 0) {
            playerMarbles--; 
            currentMarble = {
                x: plunger.x + PLUNGER_WIDTH / 2,
                y: plunger.baseY - MARBLE_RADIUS - 5, 
                radius: MARBLE_RADIUS,
                vx: 0, vy: 0, 
                color: `hsl(${Math.random() * 360}, 85%, 65%)`, 
                isActive: false, 
                hasHitPeg: false 
            };
            marbles.push(currentMarble);
            updateUI();
            return true;
        }
        updateUI(); 
        return false;
    }

    // Launches the current marble with a given power
    function launchMarble(power) {
        if (currentMarble && !currentMarble.isActive) {
            currentMarble.isActive = true;
            const baseAngle = -Math.PI * (2/3); 
            const randomFactor = (Math.random() * Math.PI / 18) - (Math.PI / 36); 
            const angle = baseAngle + randomFactor;
            
            currentMarble.vx = power * Math.cos(angle);
            currentMarble.vy = power * Math.sin(angle);
            currentMarble = null; 
        }
    }

    // Draws the plunger and its housing
    function drawPlunger() {
        ctx.fillStyle = '#a0522d'; 
        ctx.beginPath();
        ctx.moveTo(plunger.x - 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x - 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15); 
        ctx.lineTo(plunger.x - 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15); 
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#5d4037'; 
        ctx.lineWidth = 2;
        ctx.stroke();

        ctx.fillStyle = plunger.color;
        const currentPlungerY = plunger.baseY + plungerPullDistance;
        const currentPlungerHeight = plunger.height - plungerPullDistance; 
        ctx.fillRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#332a23'; 
        ctx.strokeRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);

        // Draw spring effect
        ctx.strokeStyle = '#777'; 
        ctx.lineWidth = 3;
        const springTopY = plunger.baseY + plunger.height; 
        const springBottomY = currentPlungerY + currentPlungerHeight; 
        if (springBottomY > springTopY) { 
            for(let i=0; i < 4; i++) { 
                ctx.beginPath();
                const yPos = springTopY + (i * (springBottomY - springTopY) / 4);
                ctx.moveTo(plunger.x + PLUNGER_WIDTH/2 - 6, yPos);
                ctx.lineTo(plunger.x + PLUNGER_WIDTH/2 + 6, yPos + (springBottomY - springTopY) / 8);
                ctx.stroke();
            }
        }
    }

    // Draws all marbles on the canvas
    function drawMarbles() {
        marbles.forEach(marble => {
            if (marble) { 
                ctx.beginPath();
                ctx.arc(marble.x, marble.y, marble.radius, 0, Math.PI * 2);
                ctx.fillStyle = marble.color;
                ctx.fill();
                if (marble.isActive) { 
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
            }
        });
    }

    // Draws all pegs on the canvas
    function drawPegs() {
        pegs.forEach(peg => {
            ctx.beginPath();
            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
            ctx.fillStyle = peg.color;
            ctx.fill();
            ctx.strokeStyle = '#503010'; 
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    // Draws the score holes at the bottom
    function drawHoles() {
        const now = Date.now();
        holes.forEach(hole => {
            let currentRadius = hole.baseRadius;
            let currentColor = hole.baseColor;
            let showHighlight = false;

            // Animate hole on hit
            if (now < hole.hitAnimationEndTime) {
                const timeRemaining = hole.hitAnimationEndTime - now;
                const progress = 1 - (timeRemaining / HOLE_ANIMATION_DURATION); 
                const scaleFactor = 1 + 0.2 * Math.sin(progress * Math.PI); 
                currentRadius = hole.baseRadius * scaleFactor;
                currentColor = '#FFFF99'; 
                showHighlight = true;
            }

            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; 
            ctx.fill();

            ctx.beginPath();
            ctx.arc(hole.x, hole.y, currentRadius - 3, 0, Math.PI * 2); 
            ctx.fillStyle = currentColor;
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke(); 

            ctx.fillStyle = showHighlight ? '#333' : 'white'; 
            let fontSize = 12;
            if (Math.abs(hole.value) >= 100 || (hole.value < 0 && Math.abs(hole.value) >= 10)) fontSize = 10;
            else if (Math.abs(hole.value) >= 10) fontSize = 11; 
            
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(hole.value, hole.x, hole.y);
        });
    }

    // Updates physics and checks for collisions for all active marbles
    function updateMarbles() {
        for (let i = marbles.length - 1; i >= 0; i--) { 
            const marble = marbles[i];
            if (!marble || !marble.isActive) continue; 

            // Apply gravity and move marble
            marble.vy += GRAVITY;
            marble.x += marble.vx;
            marble.y += marble.vy;

            // Safety check for invalid marble properties
            if (isNaN(marble.x) || isNaN(marble.y) || isNaN(marble.vx) || isNaN(marble.vy) ||
                !isFinite(marble.x) || !isFinite(marble.y) || !isFinite(marble.vx) || !isFinite(marble.vy)) {
                const errorMsg = `CRITICAL: Marble ${i} has invalid properties! x:${marble.x}, y:${marble.y}, vx:${marble.vx}, vy:${marble.vy}`;
                displayErrorOnScreen(errorMsg); 
                marbles.splice(i, 1); 
                continue; 
            }


            // Wall collisions
            if (marble.x - marble.radius < 0) { 
                marble.x = marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            } else if (marble.x + marble.radius > CANVAS_WIDTH) { 
                marble.x = CANVAS_WIDTH - marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            }
            if (marble.y - marble.radius < 0 && marble.vy < 0) { 
                marble.y = marble.radius;
                marble.vy *= -BOUNCE_FACTOR;
            }

            // Peg collisions
            pegs.forEach(peg => {
                const dx = marble.x - peg.x;
                const dy = marble.y - peg.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadii = marble.radius + peg.radius;

                if (distance < combinedRadii && distance > 0) { 
                    marble.hasHitPeg = true; 
                    const overlap = combinedRadii - distance;
                    const angle = Math.atan2(dy, dx);

                    // Separate the overlapping marble and peg
                    marble.x += Math.cos(angle) * overlap * 0.5; 
                    marble.y += Math.sin(angle) * overlap * 0.5;

                    // Reflect velocity
                    const normalX = dx / distance;
                    const normalY = dy / distance;
                    const dotProduct = marble.vx * normalX + marble.vy * normalY;
                    marble.vx = (marble.vx - 2 * dotProduct * normalX) * BOUNCE_FACTOR;
                    marble.vy = (marble.vy - 2 * dotProduct * normalY) * BOUNCE_FACTOR;
                    
                    // Add a slight random factor to prevent predictable paths
                    marble.vx += (Math.random() - 0.5) * 0.3; 
                    marble.vy += (Math.random() - 0.5) * 0.3;
                }
            });

            // Hole collisions
            let marbleRemoved = false;
            holes.forEach(hole => {
                const dx = marble.x - hole.x;
                const dy = marble.y - hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hole.baseRadius) { 
                    score += hole.value;
                    marbles.splice(i, 1); 
                    marbleRemoved = true;
                    updateUI();

                    // Trigger hole animation and sound
                    hole.hitAnimationEndTime = Date.now() + HOLE_ANIMATION_DURATION; 
                    if (holeHitSynth && audioContextStarted) {
                        let freq; 
                        if (hole.value > 0) {
                            freq = 200 + hole.value * 8; 
                        } else if (hole.value < 0) {
                            freq = 150 + hole.value * 6; 
                        } else { 
                            freq = 180;
                        }
                        freq = Math.max(80, Math.min(freq, 1200)); 
                        try { 
                           holeHitSynth.triggerAttackRelease(freq, "8n", "+0.02"); 
                        } catch(e) {
                            displayErrorOnScreen("Hole sound error: " + e.message);
                        }
                    }
                    // Check if a new marble should be loaded
                    if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                        needsNewMarbleInPlunger = true;
                    }
                    return; 
                }
            });

            if (marbleRemoved) continue; 

            // Remove marble if it falls off the bottom
            if (marble.y - marble.radius > CANVAS_HEIGHT) {
                if (!marble.hasHitPeg) { 
                    score = Math.max(0, score - 1); 
                }
                marbles.splice(i, 1); 
                updateUI();
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                    needsNewMarbleInPlunger = true;
                }
            }
        }
    }

    // Main game loop function
    function gameLoop() {
        if (isQuizModeActive) { 
            return; 
        }
        try { 
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 

            drawPlunger();
            drawPegs();
            drawHoles(); 
            drawMarbles();

            // Load a new marble if needed
            if (needsNewMarbleInPlunger && playerMarbles > 0 && !currentMarble && !isQuizModeActive) {
                if (!marbles.some(m => m && m.isActive)) { 
                    createMarble();
                    needsNewMarbleInPlunger = false;
                }
            }
            
            // Update active marbles
            if (marbles.some(m => m && m.isActive)) { 
                 updateMarbles();
            }

            // Check for game over condition
            if (playerMarbles <= 0 && !marbles.some(m => m && m.isActive) && !currentMarble) {
                enterQuizMode(); 
            } else {
                gameLoopId = requestAnimationFrame(gameLoop); 
            }
        } catch (e) {
            displayErrorOnScreen("Error in gameLoop: " + e.message + (e.stack ? " | Stack: " + e.stack.split('\n').slice(0,3).join('; ') : ""));
        }
    }

    // Displays the "Game Over" message
    function displayGameOverMessage() {
        if(gameLoopId) cancelAnimationFrame(gameLoopId); 
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; 
        ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 120);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 15);
        ctx.font = '20px Arial';
        ctx.fillText('Final Score: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);
    }
    
    // Enters quiz mode when the player is out of marbles
    function enterQuizMode() {
        if (isQuizModeActive) return; 
        if (quizQuestions.length === 0) {
            const errMsg = "No quiz questions available, ending game.";
            console.log(errMsg);
            displayErrorOnScreen(errMsg);
            displayGameOverMessage(); 
            return;
        }
        isQuizModeActive = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId); 

        loadNewQuizQuestion();
        quizModal.style.display = 'flex'; 
        quizAnswerInput.value = '';
        quizAnswerInput.focus();
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    // Loads a new random question into the quiz modal
    function loadNewQuizQuestion() {
        if (quizQuestions.length === 0) {
            quizQuestionEl.textContent = "No more questions available.";
            submitAnswerButton.disabled = true;
            return;
        }
        const randomIndex = Math.floor(Math.random() * quizQuestions.length);
        currentQuizQuestionObj = quizQuestions[randomIndex];

        const { textPart1, textPart2, foundPlaceholderText, clueForDisplayIfNoPlaceholder } = currentQuizQuestionObj;

        let finalQuestionHtml = "";

        // Construct the question string with placeholders
        if (foundPlaceholderText) {
            const boldedIdentifiedPlaceholder = `<b>${foundPlaceholderText}</b>`;
            let questionParts = [];
            if (textPart1 && textPart1.length > 0) questionParts.push(textPart1);
            questionParts.push(boldedIdentifiedPlaceholder);
            if (textPart2 && textPart2.length > 0) questionParts.push(textPart2);
            finalQuestionHtml = questionParts.join(" ");
        } else {
            finalQuestionHtml = clueForDisplayIfNoPlaceholder;
        }

        quizQuestionEl.innerHTML = finalQuestionHtml; 
        quizAnswerInput.value = '';
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
        submitAnswerButton.disabled = false; 
    }

    // Adds a word to the correct or incorrect list on the side
    function addWordToList(word, listElement, isCorrect) {
        const li = document.createElement('li');
        if (isCorrect) {
            correctAnswersCount++;
            li.textContent = `${correctAnswersCount}. ${word}`;
        } else {
            incorrectAnswersCount++;
            li.textContent = `${incorrectAnswersCount}. ${word}`; 
        }
        listElement.appendChild(li);
        listElement.scrollTop = listElement.scrollHeight; 
    }

    /**
     * Handles quiz answer submission, providing feedback and variable marble rewards.
     */
    function handleSubmitQuizAnswer() {
        if (!currentQuizQuestionObj || !isQuizModeActive) return;
        const userAnswer = quizAnswerInput.value.trim();
        const correctAnswer = currentQuizQuestionObj.answer;

        if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
            const rewardValue = currentQuizQuestionObj.rewardValue || 0.5; // Default reward
            let marblesAwarded = 0;

            if (rewardValue === 1.5) {
                marblesAwarded = 2;
            } else { // Default for 0.5 and any other value
                marblesAwarded = 1;
            }

            playerMarbles += marblesAwarded;

            // --- MODIFICATION: Updated feedback message to be dynamic ---
            const marbleText = marblesAwarded === 1 ? 'marble' : 'marbles';
            quizMessageEl.textContent = `Correct! You get ${marblesAwarded} ${marbleText}.`;

            quizMessageEl.className = 'quizCorrect';
            updateUI();
            addWordToList(correctAnswer, correctWordsUl, true);
        } else {
            quizMessageEl.textContent = 'Incorrect. Try another question!';
            quizMessageEl.className = 'quizIncorrect';
            addWordToList(correctAnswer, incorrectWordsUl, false);
        }

        // Display the question with the correct answer filled in for learning
        const { textPart1, textPart2, foundPlaceholderText, clueForDisplayIfNoPlaceholder } = currentQuizQuestionObj;
        const styledAnswer = `<u><b>${correctAnswer}</b></u>`;
        let questionWithAnswerHtml = "";

        if (foundPlaceholderText) {
            let parts = [];
            if (textPart1) parts.push(textPart1);
            parts.push(styledAnswer);
            if (textPart2) parts.push(textPart2);
            questionWithAnswerHtml = parts.join(" ");
        } else {
            questionWithAnswerHtml = `${clueForDisplayIfNoPlaceholder} (Answer: ${styledAnswer})`;
        }
        quizQuestionEl.innerHTML = questionWithAnswerHtml;

        submitAnswerButton.disabled = true;
        setTimeout(() => {
            loadNewQuizQuestion();
            if (quizAnswerInput.offsetParent !== null) quizAnswerInput.focus();
        }, 1500);
    }
    
    // Closes the quiz modal and returns to the game
    function handleCloseQuiz() {
        quizModal.style.display = 'none';
        isQuizModeActive = false;

        if (playerMarbles <= 0 && !currentMarble && !marbles.some(m=> m && m.isActive)) {
            displayGameOverMessage();
        } else {
            if (playerMarbles > 0 && !currentMarble && !marbles.some(m => m && m.isActive)) {
                 needsNewMarbleInPlunger = true; 
            }
            gameLoop(); 
        }
    }

    // --- Event Listeners for Plunger Interaction ---
    let startInputY; 

    // Handles the start of a drag/touch on the plunger
    async function handlePlungerStart(clientX, clientY) {
        if (isQuizModeActive) return;

        // Start Tone.js audio context on first user interaction
        if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
            try {
                await Tone.start();
                audioContextStarted = true;
                console.log('Audio context started successfully by user interaction.');
            } catch (error) {
                displayErrorOnScreen('Failed to start audio context: ' + error.message);
            }
        }

        const rect = canvas.getBoundingClientRect();
        const inputX = clientX - rect.left;
        const inputY = clientY - rect.top;

        // Check if the interaction is within the plunger's area
        if (inputX >= plunger.x && inputX <= plunger.x + plunger.width &&
            inputY >= plunger.baseY && inputY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) { 
            
            // Create a marble if one isn't ready
            if (!currentMarble) { 
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive)) { 
                    createMarble(); 
                } else {
                    return; 
                }
            }

            if (currentMarble && !currentMarble.isActive) { 
                isDraggingPlunger = true;
                startInputY = inputY; 
                plungerPullDistance = 0; 
            }
        }
    }

    // Handles the movement during a drag/touch on the plunger
    function handlePlungerMove(clientY) {
        if (isQuizModeActive || !isDraggingPlunger) return;
        
        const rect = canvas.getBoundingClientRect();
        const inputY = clientY - rect.top;
        
        let pull = inputY - startInputY; 
        if (pull < 0) pull = 0; 
        if (pull > MAX_PULL_DISTANCE) pull = MAX_PULL_DISTANCE; 
        plungerPullDistance = pull;
    }

    // Handles the end of a drag/touch on the plunger, launching the marble
    function handlePlungerEnd() {
        if (isQuizModeActive || !isDraggingPlunger) return;
        isDraggingPlunger = false;
        if (plungerPullDistance > 5) { 
            const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4; 
            launchMarble(launchPower);
        }
        plungerPullDistance = 0; 
    }


    // Mouse event listeners
    canvas.addEventListener('mousedown', (e) => { 
        handlePlungerStart(e.clientX, e.clientY);
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDraggingPlunger && e.buttons === 1) { 
             handlePlungerMove(e.clientY);
        } else if (isDraggingPlunger && e.buttons !== 1) { // Catches mouseup outside canvas
            handlePlungerEnd();
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    canvas.addEventListener('mouseleave', () => { 
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    // Touch event listeners for mobile support
    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length > 0) {
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
             // Prevent default scroll/zoom only if interacting with the plunger
             if (touchX >= plunger.x && touchX <= plunger.x + plunger.width &&
                 touchY >= plunger.baseY && touchY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) {
                 e.preventDefault(); 
            }
            handlePlungerStart(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false }); 

    canvas.addEventListener('touchmove', (e) => {
        if (isDraggingPlunger && e.touches.length > 0) {
            e.preventDefault(); 
            handlePlungerMove(e.touches[0].clientY);
        }
    }, { passive: false }); 

    canvas.addEventListener('touchend', () => {
        if (isDraggingPlunger) {
             handlePlungerEnd();
        }
    });

    canvas.addEventListener('touchcancel', () => { 
        if (isDraggingPlunger) {
            handlePlungerEnd();
        }
    });

    // UI button event listeners
    submitAnswerButton.addEventListener('click', handleSubmitQuizAnswer);
    quizAnswerInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            handleSubmitQuizAnswer();
        }
    });
    closeQuizButton.addEventListener('click', handleCloseQuiz);
    resetButton.addEventListener('click', initGame);
    
    // Initial game start
    window.onload = function() {
        initGame(); 
    };

</script>

</body>
</html>
