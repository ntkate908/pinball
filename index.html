<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiwanese Pinball Simulation (彈珠台)</title>
    <style>
        /* Basic styling for the page */
        body {
            font-family: 'Inter', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            position: relative;
        }
        h1 {
            color: #6a4f40;
            margin-bottom: 10px;
        }

        /* Main game area layout */
        #gameContainer {
            display: flex;
            flex-direction: row; /* Arrange items horizontally */
            align-items: flex-start; /* Align items to the top */
            justify-content: center; /* Center the whole container */
            gap: 15px; /* Space between canvas and word lists */
            margin-top: 10px;
        }

        /* Word list styling */
        .wordList {
            width: 120px; /* Fixed width for word lists */
            padding: 10px;
            background-color: #fff8e1;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            height: calc(600px - 22px); /* Match canvas height minus padding/border */
            overflow-y: auto; /* Scroll if content overflows */
            font-size: 0.9em;
        }
        .wordList h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            color: #5d4037;
            text-align: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        .wordList ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .wordList ul li {
            padding: 3px 0;
            border-bottom: 1px dashed #eee;
            word-wrap: break-word; /* Ensure long words break */
        }
        .wordList ul li:last-child {
            border-bottom: none;
        }

        /* Canvas styling */
        canvas {
            border: 3px solid #4a3b31;
            background-color: #deb887;
            display: block;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        /* Controls container styling */
        #controls {
            margin-top: 20px;
            padding: 15px 20px;
            background-color: #fff8e1;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            border: 1px solid #e0e0e0;
        }
        #controls p {
            margin: 8px 0;
            font-size: 1.1em;
            color: #5d4037;
        }
        /* Button styling */
        button {
            padding: 12px 20px;
            font-size: 1.05em;
            background-color: #c87638;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
        }
        button:hover {
            background-color: #b5652c;
            transform: translateY(-1px);
        }
        button:active {
            background-color: #a05420;
            transform: translateY(0px);
        }
        /* Instructions styling */
        #instructions {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.95em;
            color: #666;
            max-width: 400px; /* Max width for instructions below canvas */
            text-align: center;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }


        /* Quiz Modal Styling */
        #quizModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        #quizContent {
            background-color: #fff8e1;
            padding: 25px 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            width: 90%;
            max-width: 450px;
            border: 2px solid #c87638;
        }
        #quizContent h2 {
            color: #6a4f40;
            margin-top: 0;
            margin-bottom: 15px;
        }
        #quizQuestion {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #333;
            line-height: 1.5;
        }
        #quizAnswerInput {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
            border: 1px solid #ccc;
            width: calc(100% - 22px);
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        #quizMessage {
            margin-top: 10px;
            font-weight: bold;
            min-height: 1.2em;
        }
        .quizCorrect { color: green; }
        .quizIncorrect { color: red; }
        #quizButtons button {
            margin: 5px;
        }

    </style>
</head>
<body>

    <h1>台灣彈珠台 (Taiwanese Pinball)</h1>

    <div id="gameContainer">
        <div id="incorrectWordsList" class="wordList">
            <h3>Incorrect Guesses (答錯的詞)</h3>
            <ul id="incorrectWordsUl"></ul>
        </div>
        <canvas id="pinballCanvas"></canvas>
        <div id="correctWordsList" class="wordList">
            <h3>Correct Answers (答對的詞)</h3>
            <ul id="correctWordsUl"></ul>
        </div>
    </div>

    <div id="controls">
        <p>Marbles Left (剩餘彈珠): <span id="marblesLeft">0</span></p>
        <p>Score (得分): <span id="score">0</span></p>
        <button id="resetButton">New Game (新遊戲)</button>
    </div>
    <div id="instructions">
        <p>Click and drag the plunger (bottom right) downwards to set power, then release to launch.</p>
        <p>點擊並向下拖動右下角的彈簧桿設置力度，然後釋放以發射彈珠。</p>
        <p style="font-size:0.8em; color: #777;">(Note: "Marbles Left" shows your reserve. One is used when loaded into the plunger.)</p>
    </div>

    <div id="quizModal">
        <div id="quizContent">
            <h2>Quiz Time! (問答時間!)</h2>
            <p id="quizQuestion">Question text will appear here.</p>
            <input type="text" id="quizAnswerInput" placeholder="Your answer (你的答案)">
            <div id="quizButtons">
                <button id="submitAnswerButton">Submit Answer (提交答案)</button>
                <button id="closeQuizButton">Close Quiz (關閉問答)</button>
            </div>
            <p id="quizMessage"></p>
        </div>
    </div>

<script>
    // Get canvas and context
    const canvas = document.getElementById('pinballCanvas');
    const ctx = canvas.getContext('2d');

    // Get UI elements
    const marblesLeftEl = document.getElementById('marblesLeft');
    const scoreEl = document.getElementById('score');
    const resetButton = document.getElementById('resetButton');
    // const debugMarblesValEl = document.getElementById('debugMarblesVal'); // DEBUG ELEMENT REMOVED

    // Word list UL elements
    const correctWordsUl = document.getElementById('correctWordsUl');
    const incorrectWordsUl = document.getElementById('incorrectWordsUl');

    // Quiz Modal Elements
    const quizModal = document.getElementById('quizModal');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizAnswerInput = document.getElementById('quizAnswerInput');
    const submitAnswerButton = document.getElementById('submitAnswerButton');
    const closeQuizButton = document.getElementById('closeQuizButton');
    const quizMessageEl = document.getElementById('quizMessage');


    // Game settings
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 600;
    const MARBLE_RADIUS = 8;
    const PEG_RADIUS = 4;
    const GRAVITY = 0.15;
    const BOUNCE_FACTOR = 0.65;
    const LAUNCH_AREA_HEIGHT = 80;
    const PLUNGER_WIDTH = 20;
    const PLUNGER_HEIGHT = 70;
    const MAX_PULL_DISTANCE = 60;
    const INITIAL_MARBLES = 5;

    // Set canvas dimensions
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // Game state variables
    let marbles = [];
    let pegs = [];
    let holes = [];
    let playerMarbles; // Marbles in supply
    let score;
    let currentMarble = null; // Marble in plunger
    let isDraggingPlunger = false;
    let plungerPullDistance = 0;
    let gameLoopId;
    let isQuizModeActive = false;
    let currentQuizQuestionObj = null;
    let correctAnswersCount = 0;
    let incorrectAnswersCount = 0;
    let needsNewMarbleInPlunger = false;

    // Plunger properties
    const plunger = {
        x: CANVAS_WIDTH - PLUNGER_WIDTH - 15,
        baseY: CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT + (LAUNCH_AREA_HEIGHT - PLUNGER_HEIGHT) / 2,
        width: PLUNGER_WIDTH,
        height: PLUNGER_HEIGHT,
        color: '#4a3b31'
    };
    plunger.y = plunger.baseY;

    const quizQuestions = [
        { textPart1: "The flight attendant welcomed us", textPart2: "the airplane.", answer: "aboard" },
        { textPart1: "Can you accept a job that pays more, but makes you work longer hours? Yes, it's", textPart2: "to me.", answer: "acceptable" },
        { textPart1: "Unfortunately, the man was in a car", textPart2: ", and had to go to the hospital.", answer: "accident" },
        { textPart1: "How much money do you have in your bank", textPart2: "?", answer: "account" },
        { textPart1: "Please make sure your calculations are", textPart2: ", i.e., correct.", answer: "accurate" },
        { textPart1: "As people get older, they get all kinds of", textPart2: "and pains in their bodies.", answer: "aches" },
        { textPart1: "By the time he was only 12, he'd", textPart2: "what no Minecraft player had ever done before: beating the game in under 30 seconds.", answer: "accomplished" },
        { textPart1: "What's the hardest", textPart2: "you've unlocked in Minecraft? I've beaten the Ender Dragon.", answer: "achievement" },
        { textPart1: "These days, you need more than good grades to get into a top college. You also need to do some", textPart2: ", like basketball, chess, or piano.", answer: "activities" },
        { textPart1: "He said he beat up the bad guys by himself, but the", textPart2: "story was quite different.", answer: "actual" },
        { textPart1: "To prepare for the big test, there will be", textPart2: "(extra) class time next week.", answer: "additional" }
    ];

    /**
     * Initializes or resets the game state.
     */
    function initGame() {
        playerMarbles = INITIAL_MARBLES;
        score = 0;
        marbles = [];
        currentMarble = null;
        isDraggingPlunger = false;
        plungerPullDistance = 0;
        isQuizModeActive = false;
        quizModal.style.display = 'none';
        correctAnswersCount = 0;
        incorrectAnswersCount = 0;
        needsNewMarbleInPlunger = true;
        correctWordsUl.innerHTML = '';
        incorrectWordsUl.innerHTML = '';
        updateUI();
        setupBoard();
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        gameLoop();
    }

    /**
     * Sets up the pegs and winning holes on the game board.
     */
    function setupBoard() {
        pegs = [];
        holes = [];
        const rows = 13;
        const cols = 8;
        const xSpacing = (CANVAS_WIDTH - 40) / cols;
        const ySpacing = (CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 180) / rows;
        const xOffset = 20; // Initial horizontal offset for the peg grid
        const marbleStartX = plunger.x + PLUNGER_WIDTH / 2;
        const marbleStartY = plunger.baseY - MARBLE_RADIUS - 5;

        // Define a more aggressive rectangular clear zone for launch path
        const clearRectX1 = marbleStartX - 150; // Clear much further to the left
        const clearRectX2 = marbleStartX + MARBLE_RADIUS + 20; // Clear a bit more to the right of marble
        const clearRectY1 = marbleStartY - 300; // Clear higher above
        const clearRectY2 = CANVAS_HEIGHT;      // Clear all the way down the chute

        for (let i = 0; i < rows; i++) {
            const numColsThisRow = (i % 2 === 0) ? cols : cols - 1;
            for (let j = 0; j < numColsThisRow; j++) {
                let pegX = (j * xSpacing) + xOffset;
                if (i % 2 !== 0) { // Stagger alternate rows
                    pegX += xSpacing / 2;
                }
                const pegY = 90 + i * ySpacing; // Y position for this row of pegs
                let skipPeg = false;

                // Check if the peg's center falls within the defined clear rectangle
                if (pegX > clearRectX1 && pegX < clearRectX2 &&
                    pegY > clearRectY1 && pegY < clearRectY2) {
                    skipPeg = true;
                }

                if (!skipPeg && pegX + PEG_RADIUS < CANVAS_WIDTH - xOffset && pegX - PEG_RADIUS > xOffset) {
                     pegs.push({ x: pegX, y: pegY, radius: PEG_RADIUS, color: '#704214' });
                }
            }
        }
        const holeValues = [50, 25, 10, 5, 3, 1, -1];
        const holeRadius = 16;
        const holeY = CANVAS_HEIGHT - 60;
        const numHoles = holeValues.length;
        const holeSpacing = (CANVAS_WIDTH - 40) / (numHoles);
        const firstHoleX = 20 + holeSpacing / 2;
        for (let i = 0; i < numHoles; i++) {
            holes.push({
                x: firstHoleX + i * holeSpacing,
                y: holeY,
                radius: holeRadius,
                value: holeValues[i],
                color: `hsl(${20 + i * (300 / numHoles)}, 70%, 55%)`
            });
        }
    }

    /**
     * Updates the displayed score, number of marbles left in supply.
     */
    function updateUI() {
        marblesLeftEl.textContent = playerMarbles;
        scoreEl.textContent = score;
        // debugMarblesValEl.textContent = playerMarbles; // DEBUG LINE REMOVED
    }

    /**
     * Creates a new marble object for the plunger if supply allows.
     * Decrements 'playerMarbles' (supply) by 1.
     * Sets 'currentMarble' to this new marble.
     * Adds the new marble (inactive) to the 'marbles' array for drawing.
     */
    function createMarble() {
        if (playerMarbles > 0) {
            playerMarbles--;
            currentMarble = {
                x: plunger.x + PLUNGER_WIDTH / 2,
                y: plunger.baseY - MARBLE_RADIUS - 5,
                radius: MARBLE_RADIUS,
                vx: 0, vy: 0,
                color: `hsl(${Math.random() * 360}, 85%, 65%)`,
                isActive: false,
                hasHitPeg: false
            };
            marbles.push(currentMarble);
            updateUI();
            return true;
        }
        updateUI();
        return false;
    }

    /**
     * Launches the 'currentMarble' (the one in the plunger).
     * The marble object (which is already in 'marbles' array) is set to active.
     * 'currentMarble' (plunger reference) is set to null, indicating plunger is empty.
     */
    function launchMarble(power) {
        if (currentMarble && !currentMarble.isActive) {
            currentMarble.isActive = true;
            const baseAngle = -Math.PI * (2/3);
            const randomFactor = (Math.random() * Math.PI / 18) - (Math.PI / 36);
            const angle = baseAngle + randomFactor;
            currentMarble.vx = power * Math.cos(angle);
            currentMarble.vy = power * Math.sin(angle);
            currentMarble = null; // Plunger is now empty
        }
    }

    /**
     * Draws the plunger mechanism.
     */
    function drawPlunger() {
        ctx.fillStyle = '#a0522d';
        ctx.beginPath();
        ctx.moveTo(plunger.x - 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x - 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 8, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT);
        ctx.lineTo(plunger.x + PLUNGER_WIDTH + 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.lineTo(plunger.x - 18, CANVAS_HEIGHT - LAUNCH_AREA_HEIGHT - 15);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#5d4037';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = plunger.color;
        const currentPlungerY = plunger.baseY + plungerPullDistance;
        const currentPlungerHeight = plunger.height - plungerPullDistance;
        ctx.fillRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#332a23';
        ctx.strokeRect(plunger.x, currentPlungerY, plunger.width, currentPlungerHeight);
        ctx.strokeStyle = '#777';
        ctx.lineWidth = 3;
        const springTopY = plunger.baseY + plunger.height;
        const springBottomY = currentPlungerY + currentPlungerHeight;
        if (springBottomY > springTopY) {
            for(let i=0; i < 4; i++) {
                ctx.beginPath();
                const yPos = springTopY + (i * (springBottomY - springTopY) / 4);
                ctx.moveTo(plunger.x + PLUNGER_WIDTH/2 - 6, yPos);
                ctx.lineTo(plunger.x + PLUNGER_WIDTH/2 + 6, yPos + (springBottomY - springTopY) / 8);
                ctx.stroke();
            }
        }
    }

    /**
     * Draws all marbles from the 'marbles' array (active or inactive in plunger).
     */
    function drawMarbles() {
        marbles.forEach(marble => {
            if (marble) {
                ctx.beginPath();
                ctx.arc(marble.x, marble.y, marble.radius, 0, Math.PI * 2);
                ctx.fillStyle = marble.color;
                ctx.fill();
                if (marble.isActive) {
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                } else {
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        });
    }

    /**
     * Draws all pegs on the canvas.
     */
    function drawPegs() {
        pegs.forEach(peg => {
            ctx.beginPath();
            ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
            ctx.fillStyle = peg.color;
            ctx.fill();
            ctx.strokeStyle = '#503010';
            ctx.lineWidth = 1;
            ctx.stroke();
        });
    }

    /**
     * Draws all winning holes on the canvas.
     */
    function drawHoles() {
        holes.forEach(hole => {
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(hole.x, hole.y, hole.radius - 3, 0, Math.PI * 2);
            ctx.fillStyle = hole.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'white';
            let fontSize = 12;
            if (hole.value >= 100 || hole.value <= -10) fontSize = 8;
            else if (hole.value >= 10 || hole.value < 0) fontSize = 10;
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(hole.value, hole.x, hole.y);
        });
    }

    /**
     * Updates the position and physics of all active marbles.
     */
    function updateMarbles() {
        for (let i = marbles.length - 1; i >= 0; i--) {
            const marble = marbles[i];
            if (!marble || !marble.isActive) continue;

            marble.vy += GRAVITY;
            marble.x += marble.vx;
            marble.y += marble.vy;

            if (marble.x - marble.radius < 0) {
                marble.x = marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            } else if (marble.x + marble.radius > CANVAS_WIDTH) {
                marble.x = CANVAS_WIDTH - marble.radius;
                marble.vx *= -BOUNCE_FACTOR;
            }
            if (marble.y - marble.radius < 0 && marble.vy < 0) {
                marble.y = marble.radius;
                marble.vy *= -BOUNCE_FACTOR;
            }

            pegs.forEach(peg => {
                const dx = marble.x - peg.x;
                const dy = marble.y - peg.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadii = marble.radius + peg.radius;
                if (distance < combinedRadii) {
                    marble.hasHitPeg = true;
                    const overlap = combinedRadii - distance;
                    const angle = Math.atan2(dy, dx);
                    marble.x += Math.cos(angle) * overlap * 0.5;
                    marble.y += Math.sin(angle) * overlap * 0.5;
                    const normalX = dx / distance;
                    const normalY = dy / distance;
                    const dotProduct = marble.vx * normalX + marble.vy * normalY;
                    marble.vx = (marble.vx - 2 * dotProduct * normalX) * BOUNCE_FACTOR;
                    marble.vy = (marble.vy - 2 * dotProduct * normalY) * BOUNCE_FACTOR;
                    marble.vx += (Math.random() - 0.5) * 0.3;
                    marble.vy += (Math.random() - 0.5) * 0.3;
                }
            });

            let marbleRemoved = false;
            holes.forEach(hole => {
                const dx = marble.x - hole.x;
                const dy = marble.y - hole.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < hole.radius) {
                    score += hole.value;
                    // playerMarbles++; // Player does NOT get a marble back for holing
                    marbles.splice(i, 1);
                    marbleRemoved = true;
                    updateUI();
                    if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                        needsNewMarbleInPlunger = true;
                    }
                    return;
                }
            });

            if (marbleRemoved) continue;

            if (marble.y - marble.radius > CANVAS_HEIGHT) {
                if (!marble.hasHitPeg) {
                    score = Math.max(0, score - 1);
                }
                marbles.splice(i, 1);
                updateUI();
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive) && !currentMarble && !isQuizModeActive) {
                    needsNewMarbleInPlunger = true;
                }
            }
        }
    }

    /**
     * Main game loop.
     */
    function gameLoop() {
        if (isQuizModeActive) {
            return;
        }
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        drawPlunger();
        drawPegs();
        drawHoles();
        drawMarbles();

        if (needsNewMarbleInPlunger && playerMarbles > 0 && !currentMarble && !isQuizModeActive) {
            if (!marbles.some(m => m && m.isActive)) {
                createMarble();
                needsNewMarbleInPlunger = false;
            }
        }

        if (marbles.some(m => m && m.isActive)) {
             updateMarbles();
        }

        if (playerMarbles <= 0 && !marbles.some(m => m && m.isActive) && !currentMarble) {
            enterQuizMode();
        } else {
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    /**
     * Displays the final game over message on the canvas.
     */
    function displayGameOverMessage() {
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
        ctx.fillRect(0, CANVAS_HEIGHT / 2 - 60, CANVAS_WIDTH, 120);
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Game Over', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 15);
        ctx.fillText('(遊戲結束)', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 15);
        ctx.font = '20px Arial';
        ctx.fillText('Final Score (最終得分): ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 45);
    }

    /**
     * Enters the quiz mode.
     */
    function enterQuizMode() {
        if (isQuizModeActive) return;
        isQuizModeActive = true;
        if(gameLoopId) cancelAnimationFrame(gameLoopId);
        loadNewQuizQuestion();
        quizModal.style.display = 'flex';
        quizAnswerInput.value = '';
        quizAnswerInput.focus();
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    /**
     * Loads and displays a new random quiz question.
     */
    function loadNewQuizQuestion() {
        const randomIndex = Math.floor(Math.random() * quizQuestions.length);
        currentQuizQuestionObj = quizQuestions[randomIndex];
        quizQuestionEl.innerHTML = `${currentQuizQuestionObj.textPart1} <b>(a)___________</b> ${currentQuizQuestionObj.textPart2}`;
        quizAnswerInput.value = '';
        quizMessageEl.textContent = '';
        quizMessageEl.className = '';
    }

    /**
     * Adds a word to the specified list UL element on the page.
     */
    function addWordToList(word, listElement, isCorrect) {
        const li = document.createElement('li');
        if (isCorrect) {
            correctAnswersCount++;
            li.textContent = `${correctAnswersCount}. ${word}`;
        } else {
            incorrectAnswersCount++;
            li.textContent = `${incorrectAnswersCount}. ${word}`;
        }
        listElement.appendChild(li);
        listElement.scrollTop = listElement.scrollHeight;
    }

    /**
     * Handles quiz answer submission.
     */
    function handleSubmitQuizAnswer() {
        if (!currentQuizQuestionObj || !isQuizModeActive) return;
        const userAnswer = quizAnswerInput.value.trim();
        const correctAnswer = currentQuizQuestionObj.answer;

        if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
            quizMessageEl.textContent = 'Correct! You get 1 marble. (正確! 你得到1個彈珠)';
            quizMessageEl.className = 'quizCorrect';
            playerMarbles++;
            updateUI();
            addWordToList(correctAnswer, correctWordsUl, true);
            submitAnswerButton.disabled = true;
            setTimeout(() => {
                loadNewQuizQuestion();
                quizAnswerInput.focus();
                submitAnswerButton.disabled = false;
            }, 1500);
        } else {
            quizMessageEl.textContent = 'Incorrect. Try another question! (不正確. 再試一題!)';
            quizMessageEl.className = 'quizIncorrect';
            addWordToList(correctAnswer, incorrectWordsUl, false); // Log the correct answer for an incorrect guess
            submitAnswerButton.disabled = true;
            setTimeout(() => {
                loadNewQuizQuestion();
                quizAnswerInput.focus();
                submitAnswerButton.disabled = false;
            }, 1500);
        }
    }

    /**
     * Closes the quiz modal and handles game state (resume or game over).
     */
    function handleCloseQuiz() {
        quizModal.style.display = 'none';
        isQuizModeActive = false;
        if (playerMarbles <= 0 && !currentMarble && !marbles.some(m=> m && m.isActive)) {
            displayGameOverMessage();
        } else {
            if (playerMarbles > 0 && !currentMarble && !marbles.some(m => m && m.isActive)) {
                 needsNewMarbleInPlunger = true;
            }
            gameLoop();
        }
    }

    // Event Listeners for Plunger Interaction
    let startMouseY;
    canvas.addEventListener('mousedown', (e) => {
        if (isQuizModeActive) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (mouseX >= plunger.x && mouseX <= plunger.x + plunger.width &&
            mouseY >= plunger.baseY && mouseY <= plunger.baseY + plunger.height + MAX_PULL_DISTANCE) {

            if (!currentMarble) {
                if (playerMarbles > 0 && !marbles.some(m => m && m.isActive)) {
                    createMarble();
                } else {
                    return;
                }
            }
            if (currentMarble && !currentMarble.isActive) {
                isDraggingPlunger = true;
                startMouseY = mouseY;
                plungerPullDistance = 0;
            }
        }
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        const rect = canvas.getBoundingClientRect();
        const mouseY = e.clientY - rect.top;
        let pull = mouseY - startMouseY;
        if (pull < 0) pull = 0;
        if (pull > MAX_PULL_DISTANCE) pull = MAX_PULL_DISTANCE;
        plungerPullDistance = pull;
    });

    canvas.addEventListener('mouseup', () => {
        if (isQuizModeActive || !isDraggingPlunger) return;
        isDraggingPlunger = false;
        if (plungerPullDistance > 5) {
            const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4;
            launchMarble(launchPower);
        }
        plungerPullDistance = 0;
    });

    canvas.addEventListener('mouseleave', () => {
        if (isQuizModeActive || !isDraggingPlunger) return;
         if (isDraggingPlunger) {
            isDraggingPlunger = false;
            if (plungerPullDistance > 5) {
                const launchPower = (plungerPullDistance / MAX_PULL_DISTANCE) * 12 + 4;
                launchMarble(launchPower);
            }
            plungerPullDistance = 0;
        }
    });

    // Quiz Event Listeners
    submitAnswerButton.addEventListener('click', handleSubmitQuizAnswer);
    quizAnswerInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            handleSubmitQuizAnswer();
        }
    });
    closeQuizButton.addEventListener('click', handleCloseQuiz);

    // Reset button functionality
    resetButton.addEventListener('click', initGame);

    // Start the game automatically on load
    initGame();

</script>

</body>
</html>

